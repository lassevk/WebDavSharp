<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TypeMock</name>
    </assembly>
    <members>
        <member name="T:TypeMock.MockObject">
            <summary>
            MockObject is the Typemock Isolator dynamic mock object controller, this class is use for managing the
            dynamic mocks
            </summary>
            <remarks>
            Mock object have 3 stages.
            <list type="number">
            <item><description>
            Set Up - This is the stage where you 'record' what the mocked type/object expects 
            to do and what to return
            </description></item>
            <item><description>
            Run - Run the actual class under test
            </description></item>
            <item><description>
            Verify - Make sure that the mocked object acted as expected
            </description></item>
            </list>
            <para>
            These phases are managed by the <c>Mock</c> object. 
            <note>
            You cannot create a MockObject directly use MockManager.<see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/>
            </note>
            <note>
            You can create a mock object from abstract classes and interfaces.
            Typemock Isolator will dynamically create a new concrete Type that implements the abstract methods and will
            return an instance of the derived type when the <see cref="P:TypeMock.MockObject.Object"/> is called.
            When creating a mock object of a concrete type, Typemock Isolator will create an instance of that type, 
            and return the instance when the <see cref="P:TypeMock.MockObject.Object"/> is called. 
            This way you can mock sealed classes too.
            When mocking a method that is declared in a base class, Typemock Isolator will automatically create a mock for the base class
            and the mock definitions are propagated to this mock (Strict and MockConstructors).
            Note that if a base method is mocked all calls to the method are mocked even though they
            are called from derived classes
            </note>
            </para>	
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </remarks>	
        </member>
        <member name="T:TypeMock.Mock">
            <summary>
            Mock is the Typemock Isolator mock type controller, this class is use for managing the
            virtual mocks
            </summary>
            <remarks>
            Mock object have 3 stages.
            <list type="number">
            <item><description>
            Set Up - This is the stage where you 'record' what the mocked type/object expects 
            to do and what to return
            </description></item>
            <item><description>
            Run - Run the actual class under test
            </description></item>
            <item><description>
            Verify - Make sure that the mocked object acted as expected
            </description></item>
            </list>
            <para>
            These phases are managed by the <c>Mock</c> object. 
            <note>
            You cannot create a Mock directly use MockManager.<see cref="M:TypeMock.MockManager.Mock(System.Type)"/>
            </note>
            <note>
            You cannot mock Interfaces Classes, Use MockManager.<see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/>
            </note>
            <note>When mocking a method that is declared in 
            When mocking a method that is declared in 
            a base class, Typemock Isolator will only mock that method when called from the mocked type.
            When a base method is mocked and a derived class calls that method, it WON'T be mocked
            </note>
            </para>	
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </remarks>
        </member>
        <member name="T:TypeMock.IMockControl">
            <summary>
            IMockControl is the Typemock Isolator mock type controller, this interface is use for managing the
            virtual mocks
            </summary>
            <remarks>
            Mock object have 3 stages.
            <list type="number">
            <item><description>
            Set Up - This is the stage where you 'record' what the mocked type/object expects 
            to do and what to return
            </description></item>
            <item><description>
            Run - Run the actual class under test
            </description></item>
            <item><description>
            Verify - Make sure that the mocked object acted as expected
            </description></item>
            </list>
            <para>
            These phases are managed by the <c>IMockControl</c> object. 
            <note>
            You cannot create an IMockControl directly use MockManager.<see cref="M:TypeMock.MockManager.Mock(System.Type)"/> or MockManager.<see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/>
            </note>
            <note>
            When mocking a method that is declared in 
            a base class, Typemock Isolator will only mock that method when called from the mocked type.
            When a base method is mocked and a derived class calls that method, it WON'T be mocked
            </note>
            </para>	
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </remarks>
        </member>
        <member name="M:TypeMock.IMockControl.MethodSettings(System.String)">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler. Properties and 
            indexes can be tweaked using <see cref="M:TypeMock.IMockControl.MethodSettingsGetProperty(System.String)"/>,
            <see cref="M:TypeMock.IMockControl.MethodSettingsSetProperty(System.String)"/>, <see cref="M:TypeMock.IMockControl.MethodSettingsGetIndex"/> 
            and <see cref="M:TypeMock.IMockControl.MethodSettingsSetIndex"/>
            <seealso cref="M:TypeMock.IMockControl.MethodSettingsGetProperty(System.String)"/>
            <seealso cref="M:TypeMock.IMockControl.MethodSettingsSetProperty(System.String)"/>
            <seealso cref="M:TypeMock.IMockControl.MethodSettingsGetIndex"/>
            <seealso cref="M:TypeMock.IMockControl.MethodSettingsSetIndex"/>
            </remarks>
            <param name="methodName">Name of method</param>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.IMockControl.MethodSettingsGetProperty(System.String)">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <param name="propertyName">Name of Property</param>
            <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.IMockControl.MethodSettingsSetProperty(System.String)">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <param name="propertyName">Name of Property</param>
            <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.IMockControl.MethodSettingsGetIndex">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.IMockControl.MethodSettingsSetIndex">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <seealso cref="M:TypeMock.IMockControl.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectConstructor">
            <summary>
            Mock Constructor 
            </summary>
            <remarks>
            Using <c>ExpectConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectConstructor(System.Int32)">
            <summary>
            Mock Constructor
            </summary>
            <remarks>
            Using <c>ExpectConstructor </c> will verify that a constructor has been called and can be used to validate the arguments passed
            to the constructor
            </remarks>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectConstructorAlways">
            <summary>
            Mock unlimited calls from Constructor
            </summary>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectConstructorAndThrow(System.Exception)">
            <summary>
            Mock Constructor and throw exception when constructor is called
            </summary>
            <remarks>
            Using <c>ExpectConstructorAndThrow </c> will throw an exception when the constructor
            is called
            </remarks>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedConstructor">
            <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
            <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedConstructor(System.Int32)">
            <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
            <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedCall(System.String,System.Type[])">
            <summary>
            Verify 1 call from method , continue with method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedCall(System.String,System.Int32,System.Type[])">
            <summary>
            Verify a number of calls from method , continue with method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="timesToRun">Number of times to expect</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectCall(System.String,System.Type[])">
            <summary>
            Expect 1 call from method
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectCall(System.String,System.Int32,System.Type[])">
            <summary>
            Expect a number of calls from method
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])">
            <summary>
            Expect 1 call from method, and mock return value
            </summary>
            <param name="method">Method Name</param>
            <param name="ret">Mocked return value</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Int32,System.Type[])">
            <summary>
            Expect a number of calls from method, and mock return value
            </summary>
            <param name="method">Method Name</param>
            <param name="ret">Mocked return value</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAndThrow(System.String,System.Exception,System.Type[])">
            <summary>
            Expect 1 call from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAndThrow(System.String,System.Exception,System.Int32,System.Type[])">
            <summary>
            Expect a number of calls from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAlways(System.String,System.Type[])">
            <summary>
            Expect unlimited calls from method
            </summary>
            <param name="method">Method Name</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.IMockControl.AlwaysReturn(System.String,System.Object,System.Type[])">
            <summary>
            Expect unlimited calls from method, and always returns mock value
            </summary>
            <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.IMockControl.AlwaysReturn(System.String,System.Object,System.Type[])"/> is used together with <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])"/> then the first value 
            returned will be the <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])"/> values then the <see cref="M:TypeMock.IMockControl.AlwaysReturn(System.String,System.Object,System.Type[])"/> value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </remarks>
            <param name="method">Method Name</param>
            <param name="ret">Mocked return value</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
        </member>
        <member name="M:TypeMock.IMockControl.AlwaysThrow(System.String,System.Exception,System.Type[])">
            <summary>
            Expect unlimited calls from method, and always throws exception
            </summary>
            <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.IMockControl.AlwaysThrow(System.String,System.Exception,System.Type[])"/> is used together with <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])"/> then the first value 
            returned will be the <see cref="M:TypeMock.IMockControl.ExpectAndReturn(System.String,System.Object,System.Type[])"/> values then the method will throw the <see cref="M:TypeMock.IMockControl.AlwaysThrow(System.String,System.Exception,System.Type[])"/> value
            </remarks>
            <param name="method">Method Name</param>
            <param name="ex">Mocked exception</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSet(System.String)">
            <summary>
            Expect 1 set of a Property
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSet(System.String,System.Int32)">
            <summary>
            Expect a number of sets of a Property
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="timesToRun">Number of times to expect the set</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetAlways(System.String)">
            <summary>
            Expect unlimited set of a Property
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetAndThrow(System.String,System.Exception)">
            <summary>
            Expect 1 set of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetAndThrow(System.String,System.Exception,System.Int32)">
            <summary>
            Expect  a number of sets of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetAndAlwaysThrow(System.String,System.Exception)">
            <summary>
            Expect unlimited set of a Property and always mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedSet(System.String)">
            <summary>
            Verify 1 set of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedSet(System.String,System.Int32)">
            <summary>
            Verify a number of sets of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGet(System.String,System.Object)">
            <summary>
            Expect 1 get of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="value">Mocked value</param>
            <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGet(System.String,System.Object,System.Int32)">
            <summary>
            Expect a number of gets of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="value">Mocked value</param>
            <param name="timesToRun">Number of times to expect the gets</param>
            <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetAlways(System.String,System.Object)">
            <summary>
            Expect unlimited get of a Property and always mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="value">Mocked value</param>
            <exception cref="T:TypeMock.TypeMockException">If property is not found or is not correct value type</exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetAndThrow(System.String,System.Exception)">
            <summary>
            Expect 1 get of a Property and mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetAndThrow(System.String,System.Exception,System.Int32)">
            <summary>
            Expect a number of gets of a Property and mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of calls to expect</param>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetAndAlwaysThrow(System.String,System.Exception)">
            <summary>
            Expect unlimited get of a Property and always mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedGet(System.String)">
            <summary>
            Verify 1 get of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectUnmockedGet(System.String,System.Int32)">
            <summary>
            Verify a number of gets of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetIndex">
            <summary>
            Expect 1 set of an Index
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetIndex(System.Int32)">
            <summary>
            Expect a number of sets of an Index
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="timesToRun">Number of sets to expect</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetIndexAlways">
            <summary>
            Expect unlimited set of an Index
            </summary>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetIndexAndThrow(System.Exception)">
            <summary>
            Expect 1 set of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetIndexAndThrow(System.Exception,System.Int32)">
            <summary>
            Expect a number of sets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of sets to expect</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectSetIndexAndAlwaysThrow(System.Exception)">
            <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetIndex(System.Object)">
            <summary>
            Expect 1 get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="value">Mocked Index Value</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetIndex(System.Object,System.Int32)">
            <summary>
            Expect a number of get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="value">Mocked Index Value</param>
            <param name="timesToRun">Number of sets to expect</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetIndexAlways(System.Object)">
            <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
            <param name="value">Mocked Index Value</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetIndexAndThrow(System.Exception)">
            <summary>
            Expect 1 get of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetIndexAndThrow(System.Exception,System.Int32)">
            <summary>
            Expect a number of gets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of expected calls</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectGetIndexAndAlwaysThrow(System.Exception)">
            <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAddEvent(System.String)">
            <summary>
            Expect 1 event listener to be added (event += new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAddEvent(System.String,System.Int32)">
            <summary>
            Expect a number of event listeners to be added (event += new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectAddEventAlways(System.String)">
            <summary>
            Expect unlimited number of event listeners to be added (event += new EventHandler())
            </summary>
            <remarks>
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance"/>[index] property
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>
            Since Version 3.7
             </remarks>
            <param name="eventName">Name of Event</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectRemoveEvent(System.String)">
            <summary>
            Expect 1 event listener to be removed (event -= new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.IMockControl.ExpectRemoveEvent(System.String,System.Int32)">
            <summary>
            Expect a number of event listeners to be removed (event -= new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.IMockControl.AnonymousMethodOf(System.String)">
            <summary>
            Use to mock all anonymous methods that are called from within a method
            </summary>
            <param name="calledFromMethod">Method from which the anonymous method is called</param>
            <returns>Anonymous Method Mock Name</returns>
            <example>
            Assuming that we have this code
            <code lang="cs">
            public void DoSomething()
            {
            	button1.Click += delegate
            	 {
            	 	MessageBox.Show("Click!");
            	 };
            } 
            public void FireClick()
            {
            	button1.PerformClick();
            } 
            </code>
            We can Mock the button1.Click Anonymous Method as follows:
            <code lang="cs">
            [Test] 
            public void AnonymousTest()
            {
                 // Mock TestedClass 
                 Mock mock = MockManager.Mock(typeof(TestedClass)); 
                 // set up our expectations for anonymous method called in DoSomething
                 // check that the delegate will be called without displaying the message box 
                 mock.ExpectCall(mock.AnonymousMethod("DoSomething"));
                  
                 // create the instances
                 TestedClass tested = new TestedClass();
                 // Test the code 
                 tested.DoSomething();
                 tested.FireClick();
                 // Verify that all calls were made (This can be done in the [Teardown]) 
                 MockManager.Verify();
            } 
            </code>
            </example>
        </member>
        <member name="M:TypeMock.IMockControl.Clear(System.String)">
            <summary>
            Clear expectation of a method
            </summary>
            <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify"/>
            </remarks>		
            <param name="method">Name of method to remove expectations</param>
        </member>
        <member name="M:TypeMock.IMockControl.Clear">
            <summary>
            Clear all expectations 
            </summary>
            <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify"/>
            </remarks>		
        </member>
        <member name="M:TypeMock.IMockControl.MockField(System.String)">
            <summary> Create a Mock object and assign it to a given field.</summary>
            <param name="fieldName">The name of the field to be mocked</param>
            <returns>A mock object that is assigned to the field.</returns>
            <example>Show how to mock a call on a public field.
            this works on private members as well
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void MockInstanceField()
            {
                // mock next instance creation of ClassWithField 
                Mock mock = MockManager.Mock(typeof(ClassWithField));
                // mock the "field" field and set the expectation on it
                Mock mockedField = mock.MockField("field");
                mockedField.ExpectAndReturn("ReturnFive", 6);
            
                ClassWithField target = new ClassWithField();
                int actual = target.field.ReturnFive();
                // ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual);
            }
            </code>
            <code lang="vbnet">
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub MockInstanceField()
                ' mock next instance creation of ClassWithField 
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' mock the "field" field and set the expectaion on it
                Dim MockedField As Mock = mock.MockField("field")
                MockedField.ExpectAndReturn("ReturnFive", 6)
                
                Dim target As New ClassWithField
                Dim actual As Integer = target.field.ReturnFive
                ' ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual)
            End Sub
            </code>
            </example>
            <seealso cref="M:TypeMock.IMockControl.AssignField(System.String,System.Object)">AssignField</seealso>
            <exception cref="T:TypeMock.TypeMockException">If constructor is not mocked, field is not
            found or field can't be mocked</exception>
        </member>
        <member name="M:TypeMock.IMockControl.AssignField(System.String,System.Object)">
            <summary>
            Assign a new value to the given field.
            </summary>
            <param name="fieldName">The name of the field to be assigned</param>
            <param name="value">The value to assign.</param>
            <exception cref="T:TypeMock.TypeMockException">If field is not found or is static</exception>
            <seealso cref="M:TypeMock.IMockControl.MockField(System.String)"/>
            <example>
            Show how to assign values to private fields.
            this can also be done to private static fields using the 
            AssignStaticField API.
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void AssignField()
            {
                // create the new value we will assign to the field
                FieldClass replacement = new FieldClass();
                // create the mock object
                Mock mock = MockManager.Mock&lt;ClassWithField&gt;();
                // if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateField", replacement);
              
                // verify that the replacement was assigned to the newly crated instance
                ClassWithField target = new ClassWithField();
                int actual = target.GetPrivate().GetHashCode();
                Assert.AreEqual(replacement.GetHashCode(), actual);
            }
            </code>
            <code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub AssignField()
                ' create the new value we will assign to the field
                Dim Replacement As New FieldClass
                'create the mock object
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateField", Replacement)
                
                ' verify that the replacement was assigned to the newly crated instance
                Dim field As New ClassWithField
                Dim hashCode As Integer = field.GetPrivate().GetHashCode()
                Assert.AreEqual(Replacement.GetHashCode, hashCode)
            End Sub
            </code>
            </example>
        </member>
        <member name="P:TypeMock.IMockControl.CallBase">
            <summary>
            Allow mocking a method in a base class that is hidden by the mocked class 
            </summary>
            <remarks>
            In most cases there is no need to use this method as Typemock Isolator will mock all methods in the hierarcy 
            of the mocked type. CallBase should be used when a method of a base class is overriden in the mocked type,
             and there is a need to mock the base method only. 
            <example>
            <code lang="cs">
            public class BaseClass
            {
                public virtual int SomeMethod()
                {
                    return 1;
                }
            }
            
            public class DerivedClass() : BaseClass
            {
                public override int SomeMethod()
                {
                    return base.SomeMethod() + 1;
                }
            }
            
            [Test]
            public void Test()
            {
                Mock mock = MockManager.Mock(typeof(DerivedClass))
                // mock only BaseClass.SomeMethod when called from a DerivedClass Type.
                mock.CallBase.ExpectAndReturn("SomeMethod", 100);
                DerivedClass d = new DerivedClass();
                Assert.AreEqual(101, d.SomeMethod());
            }
            </code>
            <code lang="vbnet">
            Public Class BaseClass
              Public Overridable Function SomeMethod() As Integer
                Return 1
              End Function
            End Class
            
            Public Class DerivedClass
              Inherits BaseClass
              Public Overrides Function SomeMethod() As Integer
                Return 1
              End Function
             End Class
            
            &lt;Test()&gt; _
            Public Sub Test()
              Dim mock As Mock = MockManager.Mock(GetType(DerivedClass))
              ' mock only BaseClass.SomeMethod when called from a DerivedClass Type.
              mock.CallBase.ExpectAndReturn("SomeMethod", 100)
              Dim d As DerivedClass = New DerivedClass
              Assert.AreEqual(101, d.SomeMethod())      
            End Sub
            </code>    
            </example>
            </remarks>
            <exception cref="T:TypeMock.TypeMockException">If a static method is mocked</exception>
        </member>
        <member name="P:TypeMock.IMockControl.ValidateArgsOnVerify">
            <summary>
            Obsolete. Argument validation is done both on calling the method and during Verify.
            Postpone throwing validation errors till <see cref="M:TypeMock.MockManager.Verify"/> is called
            </summary>
            <remarks>
            Using ValidateArgsOnVerify, validation errors are thrown after Verify is called.
            This is useful if the validation is done in another thread and you want the thread to continue.
            When Verify is called all argument validations are shown too.
            </remarks>
        </member>
        <member name="F:TypeMock.Mock.allExpectedCallsDoneEvent">
            <exclude/>
            <summary>
            Event that is set when all expectations have been made, used for verify with timeout
            </summary>
        </member>
        <member name="F:TypeMock.Mock.m_MockedFields">
            <summary>used to store mocked fields objects which will be assigned upon object creation</summary>
        </member>
        <member name="F:TypeMock.Mock.m_AssignedFieldValues">
            <summary>Used to store fields which will be assigned to the field of the next object</summary>
        </member>
        <member name="F:TypeMock.Mock.m_IsFieldMock">
            <summary>Marks the mock as one sitting on a field (needed for license verification)</summary>
        </member>
        <member name="M:TypeMock.Mock.#ctor(TypeMock.Mock,System.Type,TypeMock.Constructor)">
            <summary>
            Constructer, keep internal
            </summary>
            <param name="staticMock">Link to mock for static methods</param>
            <param name="type">Type to be mocked</param>
            <param name="mockConstructors">flag to mock constructors</param>
        </member>
        <member name="F:TypeMock.Mock._recorder">
            <summary>
            This mock is filled when a recorder is recording on this instance 
            but it has to register on the recorder mock future instance
            </summary>
        </member>
        <member name="M:TypeMock.Mock.MethodSettings(System.String)">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler. Properties and 
            indexes can be tweaked using <see cref="M:TypeMock.Mock.MethodSettingsGetProperty(System.String)"/>,
            <see cref="M:TypeMock.Mock.MethodSettingsSetProperty(System.String)"/>, <see cref="M:TypeMock.Mock.MethodSettingsGetIndex"/> 
            and <see cref="M:TypeMock.Mock.MethodSettingsSetIndex"/>
            <seealso cref="M:TypeMock.Mock.MethodSettingsGetProperty(System.String)"/>
            <seealso cref="M:TypeMock.Mock.MethodSettingsSetProperty(System.String)"/>
            <seealso cref="M:TypeMock.Mock.MethodSettingsGetIndex"/>
            <seealso cref="M:TypeMock.Mock.MethodSettingsSetIndex"/>
            </remarks>
            <param name="methodName">Name of method</param>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.Mock.MethodSettingsGetProperty(System.String)">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <param name="propertyName">Name of Property</param>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.Mock.MethodSettingsSetProperty(System.String)">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <param name="propertyName">Name of Property</param>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.Mock.MethodSettingsGetIndex">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.Mock.MethodSettingsSetIndex">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            Currently you can set Strictness and CallEventHandler
            </remarks>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <returns>Interface to change method Behavior</returns>
        </member>
        <member name="M:TypeMock.Mock.IsMethodMocked(System.String,System.Object,System.Int32,System.String)">
            <summary>
            Check if method is in the expectation table
            </summary>
            <param name="methodName"></param>
            <param name="methodParameters"></param>
            <param name="inInstanceNumber"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:TypeMock.Mock.AddInstance">
            <summary>
            Used by StaticMock to count references of Mocks so that the last
            verify will verify the static too.
            </summary>
        </member>
        <member name="M:TypeMock.Mock.MockConstructor">
            <summary>
            Mock Constructor 
            </summary>
            <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectConstructor">
            <summary>
            Mock Constructor 
            </summary>
            <remarks>
            Using <c>ExpectConstructor </c> will verify that a constructor has been called and can be used to validate the arguments passed
            to the constructor
            </remarks>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectConstructor(System.Int32)">
            <summary>
            Mock Constructor
            </summary>
            <remarks>
            Using <c>ExpectConstructor </c> will verify that a constructor has been called and can be used to validate the arguments passed
            to the constructor
            </remarks>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectConstructorAlways">
            <summary>
            Mock unlimited calls from Constructor
            </summary>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectConstructorAndThrow(System.Exception)">
            <summary>
            Mock Constructor and throw exception when constructor is called
            </summary>
            <remarks>
            Using <c>ExpectConstructorAndThrow </c> will throw an exception when the constructor
            is called
            </remarks>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedConstructor">
            <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
            <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedConstructor(System.Int32)">
            <summary>
            Don't Mock Constructor but verify arguments 
            </summary>
            <remarks>
            Using <c>MockConstructor </c> will enable verifying arguments passed
            to the constructor
            </remarks>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectCallAndVerify(System.String)">
            <summary>
            Verify 1 call from method , continue with method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedCall(System.String,System.Type[])">
            <summary>
            Verify 1 call from method , continue with method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedCall(System.String,System.Int32,System.Type[])">
            <summary>
            Verify a number of calls from method , continue with method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="timesToRun">Number of times to expect</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectCall(System.String,System.Type[])">
            <summary>
            Expect 1 call from method
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectCall(System.String,System.Int32,System.Type[])">
            <summary>
            Expect a number of calls from method
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])">
            <summary>
            Expect 1 call from method, and mock return value
            </summary>
            <param name="method">Method Name</param>
            <param name="ret">Mocked return value</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
        </member>
        <member name="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Int32,System.Type[])">
            <summary>
            Expect a number of calls from method, and mock return value
            </summary>
            <param name="method">Method Name</param>
            <param name="ret">Mocked return value</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
        </member>
        <member name="M:TypeMock.Mock.ExpectAndThrow(System.String,System.Exception,System.Type[])">
            <summary>
            Expect 1 call from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectAndThrow(System.String,System.Exception,System.Int32,System.Type[])">
            <summary>
            Expect a number of calls from method, and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="method">Method Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectAlways(System.String,System.Type[])">
            <summary>
            Expect unlimited calls from method
            </summary>
            <param name="method">Method Name</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])">
            <summary>
            Expect unlimited calls from method, and always returns mock value
            </summary>
            <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])"/> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])"/> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])"/> values then the <see cref="M:TypeMock.Mock.AlwaysReturn(System.String,System.Object,System.Type[])"/> value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </remarks>
            <param name="method">Method Name</param>
            <param name="ret">Mocked return value</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found or doesn't return the return value type</exception>
        </member>
        <member name="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[])">
            <summary>
            Expect unlimited calls from method, and always throws exception
            </summary>
            <remarks>
            This is overridden with the limited call methods. ie. 
            when <see cref="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[])"/> is used together with <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])"/> then the first value 
            returned will be the <see cref="M:TypeMock.Mock.ExpectAndReturn(System.String,System.Object,System.Type[])"/> values then the method will throw the <see cref="M:TypeMock.Mock.AlwaysThrow(System.String,System.Exception,System.Type[])"/> value
            </remarks>
            <param name="method">Method Name</param>
            <param name="ex">Mocked exception</param>
            <param name="genericTypes">List of generic types, to mock bounded generic methods</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method is not found</exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSet(System.String)">
            <summary>
            Expect 1 set of a Property
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSet(System.String,System.Int32)">
            <summary>
            Expect a number of sets of a Property
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="timesToRun">Number of times to expect the set</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetAlways(System.String)">
            <summary>
            Expect unlimited set of a Property
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetAndThrow(System.String,System.Exception)">
            <summary>
            Expect 1 set of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetAndThrow(System.String,System.Exception,System.Int32)">
            <summary>
            Expect  a number of sets of a Property and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of times to expect the call</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetAndAlwaysThrow(System.String,System.Exception)">
            <summary>
            Expect unlimited set of a Property and always mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IPropertyParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedSet(System.String)">
            <summary>
            Verify 1 set of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedSet(System.String,System.Int32)">
            <summary>
            Verify a number of sets of a Property , continue with set method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGet(System.String,System.Object)">
            <summary>
            Expect 1 get of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="value">Mocked value</param>
            <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGet(System.String,System.Object,System.Int32)">
            <summary>
            Expect a number of gets of a Property and mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="value">Mocked value</param>
            <param name="timesToRun">Number of times to expect the gets</param>
            <exception cref="T:TypeMock.TypeMockException">If property is not found or is not the correct type</exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetAlways(System.String,System.Object)">
            <summary>
            Expect unlimited get of a Property and always mock the Property's value
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="value">Mocked value</param>
            <exception cref="T:TypeMock.TypeMockException">If property is not found or is not correct value type</exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetAndThrow(System.String,System.Exception)">
            <summary>
            Expect 1 get of a Property and mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetAndThrow(System.String,System.Exception,System.Int32)">
            <summary>
            Expect a number of gets of a Property and mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of calls to expect</param>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetAndAlwaysThrow(System.String,System.Exception)">
            <summary>
            Expect unlimited get of a Property and always mock throwing an exception
            </summary>
            <param name="property">Property Name</param>
            <param name="ex">Mocked Exception</param>
            <exception cref="T:TypeMock.TypeMockException">If property is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedGet(System.String)">
            <summary>
            Verify 1 get of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectUnmockedGet(System.String,System.Int32)">
            <summary>
            Verify a number of gets of a Property , continue with get method as normal
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="property">Property Name</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>Can Check Parameters, see <see cref="T:TypeMock.IParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If method not found or is not <c>void</c></exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetIndex">
            <summary>
            Expect 1 set of an Index
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetIndex(System.Int32)">
            <summary>
            Expect a number of sets of an Index
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="timesToRun">Number of sets to expect</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetIndexAlways">
            <summary>
            Expect unlimited set of an Index
            </summary>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetIndexAndThrow(System.Exception)">
            <summary>
            Expect 1 set of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetIndexAndThrow(System.Exception,System.Int32)">
            <summary>
            Expect a number of sets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of sets to expect</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectSetIndexAndAlwaysThrow(System.Exception)">
            <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetIndex(System.Object)">
            <summary>
            Expect 1 get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="value">Mocked Index Value</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetIndex(System.Object,System.Int32)">
            <summary>
            Expect a number of get of an Index and mock the index value
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.DynamicReturnValue"/>
            </summary>
            <param name="value">Mocked Index Value</param>
            <param name="timesToRun">Number of sets to expect</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetIndexAlways(System.Object)">
            <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
            <param name="value">Mocked Index Value</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetIndexAndThrow(System.Exception)">
            <summary>
            Expect 1 get of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetIndexAndThrow(System.Exception,System.Int32)">
            <summary>
            Expect a number of gets of an Index and mock throwing an exception
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="ex">Mocked Exception</param>
            <param name="timesToRun">Number of expected calls</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexGetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.ExpectGetIndexAndAlwaysThrow(System.Exception)">
            <summary>
            Expect unlimited set of an Index and mock throwing an exception
            </summary>
            <param name="ex">Mocked Exception</param>
            <returns>Can Check Property value, see <see cref="T:TypeMock.IIndexSetParameters"/></returns>
            <exception cref="T:TypeMock.TypeMockException">If index is  not found </exception>
        </member>
        <member name="M:TypeMock.Mock.MockField(System.String)">
            <summary> Create a Mock object and assign it to a given field.</summary>
            <param name="fieldName">The name of the field to be mocked</param>
            <returns>A mock object that is assigned to the field.</returns>
            <example>Show how to mock a call on a public field.
            this works on private members as well
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void MockInstanceField()
            {
                // mock next instance creation of ClassWithField 
                Mock mock = MockManager.Mock(typeof(ClassWithField));
                // mock the "member" field and set the expectation on it
                Mock mockedField = mock.MockField("member");
                mockedField.ExpectAndReturn("ReturnFive", 6);
            
                ClassWithField target = new ClassWithField();
                int actual = target.member.ReturnFive();
                // ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual);
            }
            </code>
            <code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub MockInstanceField()
                ' mock next instance creation of ClassWithField 
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' mock the "member" field and set the expectaion on it
                Dim MockedField As Mock = mock.MockField("member")
                MockedField.ExpectAndReturn("ReturnFive", 6)
                
                Dim target As New ClassWithField
                Dim actual As Integer = target.member.ReturnFive
                ' ReturnFive call is mocked and should return 6
                Assert.AreEqual(6, actual)
            End Sub
            </code>
            </example>
            <seealso cref="M:TypeMock.Mock.AssignField(System.String,System.Object)">AssignField</seealso>
            <exception cref="T:TypeMock.TypeMockException">If constructor is not mocked, field is not
            found or field can't be mocked</exception>
        </member>
        <member name="M:TypeMock.Mock.AssignField(System.String,System.Object)">
            <summary>
            Assign a new value to the given field.
            </summary>
            <param name="fieldName">The name of the field to be assigned</param>
            <param name="value">The value to assign.</param>
            <exception cref="T:TypeMock.TypeMockException">If field is not found or is static, or if the class's constructor is not mocked</exception>
            <seealso cref="M:TypeMock.Mock.MockField(System.String)"/>
            <example>
            Show how to assign values to private fields.
            this can also be done to private static fields using the 
            AssignStaticField API.
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void AssignField()
            {
                // create the new value we will assign to the field
                FieldClass replacement = new FieldClass();
                // create the mock object
                Mock mock = MockManager.Mock&lt;ClassWithField&gt;();
                // if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateMember", replacement);
              
                // verify that the replacement was assigned to the newly crated instance
                ClassWithField target = new ClassWithField();
                int actual = target.GetPrivate().GetHashCode();
                Assert.AreEqual(replacement.GetHashCode(), actual);
            }
            </code>
            <code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub AssignField()
                ' create the new value we will assign to the field
                Dim Replacement As New FieldClass
                'create the mock object
                Dim mock As Mock = MockManager.Mock(GetType(ClassWithField))
                ' if the field wont be assigned accessing it will yield a null reference exception
                mock.AssignField("privateMember", Replacement)
                
                ' verify that the replacement was assigned to the newly crated instance
                Dim field As New ClassWithField
                Dim hashCode As Integer = field.GetPrivate().GetHashCode()
                Assert.AreEqual(Replacement.GetHashCode, hashCode)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:TypeMock.Mock.MockAllFields">
            <summary>
            Create a mock object on all the fields (which are classes)
            done by default in natural mocks, when encountering a ctor recording
            </summary>
        </member>
        <member name="M:TypeMock.Mock.MockAllStaticFields">
            <summary>
            Create a mock object on all static fields of the class
            done by default in natural mocks when encountering a cctor recording
            </summary>
        </member>
        <member name="M:TypeMock.Mock.AssignValuesToFields(System.Object)">
            <summary>
            gop over mocked field list and atatch the mocks to the created object
            and then go over user assigned values and assign them to the fields
            this is called when creating the real object
            </summary>
            <param name="context">the real object being created</param>
        </member>
        <member name="M:TypeMock.Mock.ExpectAddEventAlways(System.String)">
            <summary>
            Expect unlimited number of event listeners to be added (event += new EventHandler())
            </summary>
            <remarks>
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance"/>[index] property
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>
            Since Version 3.7
             </remarks>
            <param name="eventName">Name of Event</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectAddEvent(System.String)">
            <summary>
            Expect 1 event listener to be added (event += new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectAddEvent(System.String,System.Int32)">
            <summary>
            Expect a number of event listeners to be added (event += new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectRemoveEvent(System.String)">
            <summary>
            Expect 1 event listener to be removed (event -= new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.Mock.ExpectRemoveEvent(System.String,System.Int32)">
            <summary>
            Expect a number of event listeners to be removed (event -= new EventHandler())
            </summary>
            <param name="eventName">Name of Event</param>
            <param name="timesToRun">Number of times to expect</param>
            <returns>A MockedEvent that can be used to <see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> the Event</returns>
        </member>
        <member name="M:TypeMock.Mock.AnonymousMethodOf(System.String)">
            <summary>
            Use to mock all anonymous methods that are called from within a method
            </summary>
            <param name="calledFromMethod">Method from which the anonymous method is called</param>
            <returns>Anonymous Method Mock Name</returns>
            <example>
            Assuming that we have this code
            <code lang="cs">
            public void DoSomething()
            {
            	button1.Click += delegate
            	 {
            	 	MessageBox.Show("Click!");
            	 };
            } 
            public void FireClick()
            {
            	button1.PerformClick();
            } 
            </code>
            We can Mock the button1.Click Anonymous Method as follows:
            <code lang="cs">
            [Test] 
            public void AnonymousTest()
            {
                 // Mock TestedClass 
                 Mock mock = MockManager.Mock(typeof(TestedClass)); 
                 // set up our expectations for anonymous method called in DoSomething
                 // check that the delegate will be called without displaying the message box 
                 mock.ExpectCall(mock.AnonymousMethod("DoSomething"));
                  
                 // create the instances
                 TestedClass tested = new TestedClass();
                 // Test the code 
                 tested.DoSomething();
                 tested.FireClick();
                 // Verify that all calls were made (This can be done in the [Teardown]) 
                 MockManager.Verify();
            } 
            </code>
            </example>
        </member>
        <member name="M:TypeMock.Mock.Verify">
            <summary>
            Verify mocked type 
            </summary>
            <remarks>
            Part of Test Driven Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. This should always be the final part of the test
            If some methods that we expected to be called where not called this will fail the test.
            
            This is automatically called when using <c>MockManager.Verify()</c> see <see cref="M:TypeMock.MockManager.Verify"/>
            <example>
            For an example see <see cref="P:TypeMock.Mock.Strict"/>
            </example>
            <note>
            Using <see cref="P:TypeMock.Mock.Strict"/> we can also define, that calls to methods that where
            not expected, will fail the test too.
            </note>
            </remarks>		
        </member>
        <member name="M:TypeMock.Mock.VerifyWithTimeout">
            <summary>
            Wait with timeout (5 seconds) for all expected methods to be called
            </summary>
            <remarks>
            VerifyWithTimeout will wait for all expectations to be called. If the Timeout is triggered
            the test will fail. 
            Part of Test Driver Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. There are cases when mocks are called in a-synchronic
            code or are encapsulated in a try catch block and errors are not thrown to testing method.
            In these cases using VerifyWithTimeout will enable us to validate our code and return as soon as
            the expected methods are called without needing to add Pause statements
            
            This is automatically called when using <c>MockManager.VerifyWithTimeout()</c> see <see cref="M:TypeMock.MockManager.VerifyWithTimeout"/>
            <example>
            <code lang="cs">
            [Test]
            public void TestCallsInOtherThread ()
            {
            	// Let mock the product -  it will not mock constructors;
            	Mock productMock = MockManager.Mock(typeof(Product),Constructor.NotMocked);
            	// CalculatePrice will return 10 - expect 10 as argument
            	productMock.ExpectAndReturn("CalculatePrice",10F).Args(10);
            	// our method will be called in a new thread
            	Thread theThread = new Thread(new ThreadStart(RunWithWait));
            	theThread.Start();
            	// If we use Verify we dont know when the thread will actually be called
            	// Here we WAIT for the mocked methods to be called, or the timeout.
            	// Default timeout is 5000 milliseconds
            	productMock.VerifyWithTimeout();		
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestCallsInOtherThread()
               ' Let mock the product - this will mock the next invocation of Product,
               ' it will mock constructors too so our price will be 0
               Dim productMock As Mock = MockManager.Mock(GetType(Product), Constructor.NotMocked)
               ' CalculatePrice will return 10 - expect 10 as argument
               productMock.ExpectAndReturn("CalculatePrice", 10.0F).Args(10)
               ' our method will be called in a new thread
               Dim theThread As Thread = New Thread(AddressOf RunWithWait)
               theThread.Start()
               ' If we use Verify we dont know when the thread will actually be called
               ' Here we WAIT for the mocked methods to be called, or the timeout.
               ' Default timeout is 5000 milliseconds
               productMock.VerifyWithTimeout()
            End Sub
            </code>
            </example>
            </remarks>		
        </member>
        <member name="M:TypeMock.Mock.VerifyWithTimeout(System.Int32)">
            <summary>
            Wait with timeout (im milliseconds) for all expected methods to be called
            </summary>
            <remarks>
            VerifyWithTimeout will wait for all expectations to be called. If the Timeout is triggered
            the test will fail. 
            Part of Test Driver Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. There are cases when mocks are called in a-synchronic
            code or are encapsulated in a try catch block and errors are not thrown to testing method.
            In these cases using VerifyWithTimeout will enable us to validate our code and return as soon as
            the expected methods are called without needing to add Pause statements
            
            This is automatically called when using <c>MockManager.VerifyWithTimeout()</c> see <see cref="M:TypeMock.MockManager.VerifyWithTimeout"/>
            <example>
            <code lang="cs">
            [Test]
            public void TestCallsInOtherThread ()
            {
            	// Let mock the product -  it will not mock constructors;
            	Mock productMock = MockManager.Mock(typeof(Product),Constructor.NotMocked);
            	// CalculatePrice will return 10 - expect 10 as argument
            	productMock.ExpectAndReturn("CalculatePrice",10F).Args(10);
            	// our method will be called in a new thread
            	Thread theThread = new Thread(new ThreadStart(RunWithWait));
            	theThread.Start();
            	// If we use Verify we dont know when the thread will actually be called
            	// Here we WAIT 1000 milliseconds for the mocked methods to be called, or the timeout.
            	productMock.VerifyWithTimeout(1000);		
            }
            </code><code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestCallsInOtherThread()
               ' Let mock the product - this will mock the next invocation of Product,
               ' it will mock constructors too so our price will be 0
               Dim productMock As Mock = MockManager.Mock(GetType(Product), Constructor.NotMocked)
               ' CalculatePrice will return 10 - expect 10 as argument
               productMock.ExpectAndReturn("CalculatePrice", 10.0F).Args(10)
               ' our method will be called in a new thread
               Dim theThread As Thread = New Thread(AddressOf RunWithWait)
               theThread.Start()
               ' If we use Verify we dont know when the thread will actually be called
               ' Here we WAIT 1000 milliseconds for the mocked methods to be called, or the timeout.
               productMock.VerifyWithTimeout(1000)
            End Sub
            </code>
            </example>
            </remarks>			
            <param name="millisecondsTimeout">Time to wait for all expected methods to be called</param>
        </member>
        <member name="M:TypeMock.Mock.Clear(System.String)">
            <summary>
            Clear expectation of a method
            </summary>
            <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify"/>
            </remarks>		
            <param name="method">Name of method to remove expectations</param>
        </member>
        <member name="M:TypeMock.Mock.Clear">
            <summary>
            Clear all expectations 
            </summary>
            <remarks>
            There are times when you want to clear all the expectations of the mock.
            For example, if you setup expectations in the [SetUp] method, but want to clear a mocked
            type in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify"/>
            </remarks>		
        </member>
        <member name="M:TypeMock.Mock.Clear(TypeMock.ExpectationBlock)">
            <summary>
            Clear expectation of an expectation block
            </summary>
            <remarks>
            There are times when you want to clear expectations of the mock.
            For example, if you use a utility class that contains an expectation block that
            is not needed in a specific test.
            
            You do not need to call this when using <see cref="M:TypeMock.Mock.Verify"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            </remarks>		
            <param name="block">The Block to Clear</param>
        </member>
        <member name="M:TypeMock.Mock.GetCallCount(System.String)">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <remarks>
            Can be used as part of a validation. 
            <example>
            In the following example we validate that the doSomething() Method has been called 3 times, 
            while keeping the original functionality (not mocked)
            </example>
            <code lang="cs">
            [Test]
            public void Test()
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	t.doSomething();
            	t.doSomething();
            	t.doSomething();
            	Assert.AreEqual(3,mock.GetCallCount("doSomething"));
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass()
            	t.doSomething()
            	t.doSomething()
            	t.doSomething()
            	Assert.AreEqual(3,mock.GetCallCount("doSomething"))
            End Sub
            </code>
            For Properties and Indexers see <see cref="M:TypeMock.Mock.GetCallPropertyGetCounter(System.String)"/> ,
            <see cref="M:TypeMock.Mock.GetCallPropertySetCounter(System.String)"/> and <see cref="M:TypeMock.Mock.GetCallIndexerCounter"/>
            <note>
            <c>mock.GetCallCount("doSomething")</c> is equivalent to 
            <c>MockManager.CalledCounter("TestClassLibrary.TestedClass","doSomething")</c>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)"/>
            </note>
            </remarks>
            <param name="method">String representation of Method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.Mock.GetCallCount(System.String,System.Type[])">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <param name="methodName">String representation of Method</param>
            <param name="genericMethodTypes">Generic parameters list of the method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.Mock.GetCallPropertyGetCounter(System.String)">
            <summary>
            Return the amount of times a property has been called
            </summary>
            <remarks>
            See <see cref="M:TypeMock.Mock.GetCallCount(System.String)"/>
            </remarks>
            <param name="propertyName">String representation of the Property</param>
            <returns>Number of times the property has been called</returns>
        </member>
        <member name="M:TypeMock.Mock.GetCallPropertySetCounter(System.String)">
            <summary>
            Return the amount of times a property has been set
            </summary>
            <remarks>
            See <see cref="M:TypeMock.Mock.GetCallCount(System.String)"/>
            </remarks>
            <param name="propertyName">String representation of the Property</param>
            <returns>Number of times the property has been set</returns>
        </member>
        <member name="M:TypeMock.Mock.GetCallIndexerCounter">
            <summary>
            Return the amount of times an indexer has been called
            </summary>
            <remarks>
            See <see cref="M:TypeMock.Mock.GetCallCount(System.String)"/>
            </remarks>
            <returns>Number of times the indexer has been called</returns>
        </member>
        <member name="M:TypeMock.Mock.StartBlock">
            <summary>
            Start an expectation block
            </summary>
            <remarks>
            <para>
            Group a number of expectation. When grouping expectations in a block you can control
            The expectation dynamically. This is very useful when setting up a mock infrastructure.
            After defining a block it is possible to:
            <list type="number">
            <item>Remove the block using <see cref="M:TypeMock.Mock.Clear(TypeMock.ExpectationBlock)"/>.
            </item>
            <item>
            Add expectations before the block using <see cref="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock)"/>.
            </item>
            </list>		 
            Blocks can be labeled and can be later on referred to by <see cref="M:TypeMock.Mock.GetBlock(System.String)"/>.
            
            Blocks can have different <see cref="T:TypeMock.VerifyMode"/>s.
            <example>
            The following example shows a utility method that sets up expectations 
            for an AccessController
            <code lang="cs">
            private Mock SetupExpectations()
            {
            	//Mock all invocation of AccessController, 
            	Mock mock = MockManager.MockAll(typeof(AccessController));
            
            	// start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal);
            	 // We expect that the login method will be called and we will return 
            	 // AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 // second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	return mock;
            }
            [Test]
            public void TestSomething()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"));
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// continue with test
            }
            [Test]
            public void TestSomething2()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"));
            	
            	// continue with test
            }
            </code>
            <code lang="vbnet">
            Private Function SetupExpectations() As Mock 
            	'Mock all invocation of AccessController, 
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal)
            	 ' We expect that the login method will be called and we will return 
            	 ' AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 ' second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	SetupExpectations = mock
            End Function
            &lt;Test()&gt; _
            Public Sub TestSomething()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"))
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' continue with test
            End Sub
            &lt;Test()&gt; _
            Public Sub TestSomething2()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"))
            	
            	' continue with test
            End Sub
            </code>
            </example>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </para>
            </remarks>
            <returns>The Expectation Block</returns>
        </member>
        <member name="M:TypeMock.Mock.StartBlock(System.String)">
            <summary>
            Start an expectation block with a label name
            </summary>
            <remarks>
            <seealso cref="M:TypeMock.Mock.StartBlock"/>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)"/> </param>
            <returns>The Expectation Block</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
        </member>
        <member name="M:TypeMock.Mock.StartBlock(TypeMock.VerifyMode)">
            <summary>
            Start an expectation block with a verify mode
            </summary>
            <remarks>
            <seealso cref="M:TypeMock.Mock.StartBlock"/>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="mode">The verify mode of the block </param>
            <returns>The Expectation Block</returns>
        </member>
        <member name="M:TypeMock.Mock.StartBlock(System.String,TypeMock.VerifyMode)">
            <summary>
            Start an expectation block with a label and a verify mode
            </summary>
            <remarks>
            <seealso cref="M:TypeMock.Mock.StartBlock"/>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)"/></param>
            <param name="mode">The verify mode of the block</param>
            <returns>The Expectation Block</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
        </member>
        <member name="M:TypeMock.Mock.GetBlock(System.String)">
            <summary>
            Retrieve Expectation Block, by its label name
            </summary>
            <param name="name">The Expectation blocks label</param>
            <returns>The Expectation block</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a block doesn't exist
            </exception>
            <seealso cref="M:TypeMock.Mock.StartBlock"/>
        </member>
        <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock)">
            <summary>
            Start an expectation block and adds the expectations before another expectation 
            block
            </summary>
            <remarks>
            Add expectations before another expectation block. This is very useful when setting up a mock infrastructure.
            
            Blocks can be labeled and can be later on referred to by <see cref="M:TypeMock.Mock.GetBlock(System.String)"/>.
            
            Blocks can have different <see cref="T:TypeMock.VerifyMode"/>s.
            <example>
            The following example shows a utility method that sets up expectations 
            for an AccessController
            <code lang="cs">
            private Mock SetupExpectations()
            {
            	//Mock all invocation of AccessController, 
            	Mock mock = MockManager.MockAll(typeof(AccessController));
            
            	// start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal);
            	 // We expect that the login method will be called and we will return 
            	 // AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 // second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	return mock;
            }
            [Test]
            public void TestSomething()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"));
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// continue with test
            }
            [Test]
            public void TestSomething2()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"));
            	
            	// continue with test
            }
            </code>
            <code lang="vbnet">
            Private Function SetupExpectations() As Mock 
            	'Mock all invocation of AccessController, 
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal)
            	 ' We expect that the login method will be called and we will return 
            	 ' AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 ' second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	SetupExpectations = mock
            End Function
            &lt;Test()&gt; _
            Public Sub TestSomething()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"))
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' continue with test
            End Sub
            &lt;Test()&gt; _
            Public Sub TestSomething2()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"))
            	
            	' continue with test
            End Sub
            </code>
            </example>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="before">The Expectations block to add expectations before</param>
            <returns>The Expectation Block</returns>
        </member>
        <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock,System.String)">
            <summary>
            Start an expectation block with a label and adds the expectations before another expectation 
            block
            </summary>
            <remarks>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="before">The Expectation block to add expectations before</param>
            <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)"/></param>
            <returns>The Expectation Block</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
        </member>
        <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock,TypeMock.VerifyMode)">
            <summary>
            Start an expectation block with a verify mode and adds the expectations before another expectation 
            block
            </summary>
            <remarks>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="before">The Expectation block to add expectations before</param>
            <param name="mode">The verify mode of the block</param>
            <returns>The Expectation Block</returns>
        </member>
        <member name="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock,System.String,TypeMock.VerifyMode)">
            <summary>
            Start an expectation block with a label and a verify mode, and adds the expectations before another expectation 
            block
            </summary>
            <remarks>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
            <param name="before">The Expectation block to add expectations before</param>
            <param name="name">The label given to the block, can then be retrieved using <see cref="M:TypeMock.Mock.GetBlock(System.String)"/></param>
            <param name="mode">The verify mode of the block</param>
            <returns>The Expectation Block</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a block with the same label name exists already
            </exception>
        </member>
        <member name="M:TypeMock.Mock.EndBlock">
            <summary>
            End an expectation block
            </summary>
            <remarks>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear"/>
            </remarks>
        </member>
        <member name="P:TypeMock.Mock.Strict">
            <summary>
            Can set the mock to be Strict
            The default is the Methods of Abstract and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
            <remarks>
            By default Mocked Concrete Types are NOT strict this mean that if a call to a mocked
            method was not expected the normal code is executed.
            Mocked Types can be made strict and fail if an unexpected call is made
            <example><code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	// No expectations, the following will run normal passInt if Strict=false
            	// and will fail if Strict=true 
            	t.passInt(10);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            {
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	' No expectations, the following will run normal passInt if Strict=false
            	' and will fail if Strict=true 
            	t.passInt(10)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            <note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            </note>
            <note>
            When allowing arbitrary abstract methods (methods created dynamically by Typemock Isolator using <see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/> or <see cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)"/>), 
            Typemock Isolator create the following default behavior:
            1. All void calls just return
            2. Other Methods will return 0 or null depending on the return type
            3. Properties will behave like normal properties
            </note>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <seealso cref="T:TypeMock.VerifyMode"/>
            </remarks>
        </member>
        <member name="P:TypeMock.Mock.StrictStatic">
            <summary>
            Can set the static methods of a mocked type to be Strict
            </summary>
            <remarks>
            By default Mocked Types are NOT strict this mean that if a call to a mocked
            method was not expected the normal code is executed.
            Mocked Types Static Members can be made strict and fail if an unexpected call is made
            <note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            </note>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <seealso cref="T:TypeMock.VerifyMode"/>
            </remarks>
        </member>
        <member name="P:TypeMock.Mock.MockedInstance">
             <summary>
             Get the actual instance that is being mocked and controlled. This 
             enables tracking instance mocks to the actual instance
             </summary>
             <note>
             When using instance mocks (Mock and MockObject) this property returns the instance mocked
             </note>
             <note>
             MockObject <see cref="P:TypeMock.MockObject.Object"/> will return the same result although has a different usage
             </note>
             <note>
             MockAll mocks and Mocks that haven't been created yet (new not called) will return null (Nothing in Visual Basic)
             </note>
             <remarks>
             Being able to reference the mocked instance enables testing fields of future object.
             Example of using Typemock Isolator to test a field of a future object
             <example>
             <code lang="cs">
            	public static void CreateAnObject()
            	{
                 TestClass theClass = new TestClass();
                 theClass.field = 5;
                 ...
             }
             [Test]
            	public void VerifyFutureObject()
            	{
            		//Create new Mock for a future Object, no expectations 
            		Mock mock = MockManager.Mock(typeof(TestClass));
            	
            		// Call our code
                 TheClass.CreateAnObject();
             
                 // get the mocked object and test the field
                 TestClass theClass = mock.MockedInstance as TestClass;
                 Assert.AreEqual(5, theClass.field);
            
            		// Verify that all the expected calls have actually been called.
            		MockManager.Verify();
             }
             </code>
             <code lang="vbnet">
            	Public Shared Sub CreateAnObject()
            		Dim theClass As TestClass = New TestClass()
                 theClass.field = 5
                 ...
             End Sub
             
             &lt;Test()&gt; _
            	Public Sub ValidateValidUser()
            		' Create new Mock for a future Object, no expectations 
            		Dim mock As Mock = MockManager.Mock(GetType(TestClass))
            	
            		' call our code
                 TheClass.CreateAnObject()
                 ' Get the mocked object and test the field
                 Dim theClass As TestClass = mock.MockedInstance 
                 Assert.AreEqual(5, theClass.field)
            	
            		' Verify that all the expected calls have actually been called.
            		MockManager.Verify()
             End Sub
             </code>
             </example>
             </remarks>
             <returns>Mock Instance</returns>
        </member>
        <member name="P:TypeMock.Mock.IsFieldMock">
            <summary>
            used to specifiy that this is a mock created for a field inside an object
            </summary>
        </member>
        <member name="P:TypeMock.Mock.CallBase">
            <summary>
            Allow mocking a method in a base class that is hidden by the mocked class 
            </summary>
            <remarks>
            In most cases there is no need to use this method as Typemock Isolator will mock all methods in the hierarcy 
            of the mocked type. CallBase should be used when a method of a base class is overriden in the mocked type,
             and there is a need to mock the base method only. 
            <example>
            <code lang="cs">
            public class BaseClass
            {
                public virtual int SomeMethod()
                {
                    return 1;
                }
            }
            
            public class DerivedClass : BaseClass
            {
                public override int SomeMethod()
                {
                    return base.SomeMethod() + 1;
                }
            }
            
            [Test]
            public void Test()
            {
                Mock mock = MockManager.Mock(typeof(DerivedClass))
                // mock only BaseClass.SomeMethod when called from a DerivedClass Type.
                mock.CallBase.ExpectAndReturn("SomeMethod", 100);
                DerivedClass d = new DerivedClass();
                Assert.AreEqual(101, d.SomeMethod());
            }
            </code>
            <code lang="vbnet">
            Public Class BaseClass
              Public Overridable Function SomeMethod() As Integer
                Return 1
              End Function
            End Class
            
            Public Class DerivedClass
              Inherits BaseClass
              Public Overrides Function SomeMethod() As Integer
                Return 1
              End Function
             End Class
            
            &lt;Test()&gt; _
            Public Sub Test()
              Dim mock As Mock = MockManager.Mock(GetType(DerivedClass))
              ' mock only BaseClass.SomeMethod when called from a DerivedClass Type.
              mock.CallBase.ExpectAndReturn("SomeMethod", 100)
              Dim d As DerivedClass = New DerivedClass
              Assert.AreEqual(101, d.SomeMethod())      
            End Sub
            </code>    
            </example>
            </remarks>
            <exception cref="T:TypeMock.TypeMockException">If a static method is mocked</exception>
        </member>
        <member name="P:TypeMock.Mock.CallStatic">
            <summary>
            Allow mocking a static method when that method is overloaded with an instance method
            <remarks>
            In most cases there is no need to use this method as Typemock Isolator will mock all static methods 
            of the mocked type. CallStatic should be used when an instance method and a static method have the same name
            By default the instance methods are returned.
            </remarks>
            <exception cref="T:TypeMock.TypeMockException">If instance methods are mocked</exception>
            </summary>
        </member>
        <member name="P:TypeMock.Mock.ValidateArgsOnVerify">
            <summary>
            Obslolete. Argument validation is done both on calling the method and during Verify.
            </summary>
            <remarks>
            Using ValidateArgsOnVerify, validation errors are thrown after Verify is called.
            This is useful if the validation is done in another thread and you want the thread to continue.
            When Verify is called all argument validations are shown too.
            </remarks>
            The flag will be deleted in future
        </member>
        <member name="P:TypeMock.Mock.MockedType">
            <summary>
            Get the type that is mocked and controlled.
            </summary>
        </member>
        <member name="E:TypeMock.Mock.MockMethodCalled">
            <summary>
            Event that is fired after a mocked method is called and after argument validation is performed
            <see cref="T:TypeMock.MockMethodCalledEventHandler"/> <seealso cref="T:TypeMock.MockMethodCalledEventHandler"/>
            </summary>
            <remarks>
            To set an event per method see <see cref="T:TypeMock.IMethodSettings"/>
            <note>When static methods are called events from ALL mocks of that type are triggered. So if a type is mocked for
            two instances, and both have AfterMock Events, both will be triggered after a static member of that type is called. This 
            is because static methods are not associated with an instance.</note>
            </remarks>
        </member>
        <member name="M:TypeMock.MockObject.#ctor(TypeMock.Mock,System.Type,TypeMock.Constructor)">
            <exclude/>
            <summary>
            Do not create this type, use MockManager.<see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/>
            </summary>
            <param name="staticMock">Link to mock for static methods</param>
            <param name="type">Type to be mocked</param>
            <param name="mockConstructors">flag to mock constructors</param>
        </member>
        <member name="P:TypeMock.MockObject.Object">
            <summary>
            Get the Mocked Object
            </summary>
        </member>
        <member name="T:TypeMock.MockObject`1">
            <summary>
            Create an instance of TMockedType and Control the behavior of that instance.
            </summary>
            <typeparam name="TMockedType">The Type to Mock</typeparam>
            <remarks>
            <see cref="T:TypeMock.Mock"/> is the Typemock Isolator mock type controller, this class is use for managing the
            virtual mocks, using generic code sugar, to ease the mock creation.
            <para>
            There are 3 types of mocks
            <list>
            <item><description>
            MockManager.<see cref="M:TypeMock.MockManager.Mock``1"/> - Will mock the next 'new' instance of the mocked Type (and all static methods) 
            </description></item>
            <item><description>
            MockManager.<see cref="M:TypeMock.MockManager.MockAll``1"/> - Will mock ALL (future and past) instances of the mocked Type
            </description></item>
            <item><description>
            MockManager.<see cref="M:TypeMock.MockManager.MockObject``1"/> - Will create ONE instance of the Type. This instance is mocked
            </description></item>
            </list>
            </para>
            <para>
            MockManager.<see cref="M:TypeMock.MockManager.MockObject``1"/>  methods are used to create a mocked instance and return a controller to defined expectations
            on the mocked instance mock.  After creating a mocked object the actual instance is in <see cref="P:TypeMock.MockObject`1.Object"/>.
            </para>
            <para>
            RecorderManager.<see cref="M:TypeMock.RecorderManager.CreateMockedObject``1"/>  methods are used to create a mocked instance and return the actual instance.
            This is useful for Natural Mocks
            </para> 
            <para>
            To mock create any object (including Interfaces) Use MockManager.<see cref="M:TypeMock.MockManager.MockObject``1"/>"/&gt;
            When creating a mock object Typemock Isolator will choose a constructor with the highest visibility and create default values for the
            arguments, to send specific arguments use MockManager.<see cref="M:TypeMock.MockManager.MockObject``1(System.Object[])"/>
            </para>
            <para>
            After creating a mocked object the actual instance is in <see cref="P:TypeMock.MockObject`1.Object"/>.
            </para>    
            <seealso cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/>
            <seealso cref="T:TypeMock.Mock"/>
            <seealso cref="T:TypeMock.MockObject"/>
            </remarks>
        </member>
        <member name="T:TypeMock.Mock`1">
            <summary>
            <see cref="T:TypeMock.Mock"/> is the Typemock Isolator mock type controller, this class is use for managing the
            virtual mocks, using generic code sugar, to ease the mock creation.
            </summary>
            <typeparam name="TMockedType">The Type to Mock</typeparam>
            <remarks>
            There are 3 types of mocks
            <list>
            <item><description>
            MockManager.<see cref="M:TypeMock.MockManager.Mock``1"/> - Will mock the next 'new' instance of the mocked Type (and all static methods) 
            </description></item>
            <item><description>
            MockManager.<see cref="M:TypeMock.MockManager.MockAll``1"/> - Will mock ALL (future and past) instances of the mocked Type
            </description></item>
            <item><description>
            MockManager.<see cref="M:TypeMock.MockManager.MockObject``1"/> - Will create ONE instance of the Type. This instance is mocked 
            </description></item>
            </list>
            <para>
            <note>
            To mock Interfaces, Use MockManager.<see cref="M:TypeMock.MockManager.MockObject``1"/>
            </note>
            </para>
            <seealso cref="T:TypeMock.Mock"/>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:TypeMock.Mock`1.MockedInstance" -->
        <member name="P:TypeMock.MockObject`1.Object">
            <summary>
            Get the mocked instance. 
            </summary>
        </member>
        <member name="F:TypeMock.MockedTypesList.MOCK_SIGNAL">
            Some Constants used to communicate with weaver.
             <summary>The name under which we store global types</summary>
        </member>
        <member name="M:TypeMock.MockedTypesList.AddTypeWithHierarchy(System.Type)">
            <summary>
            Adds the type with all its base classes to the mocked list
            </summary>
            <param name="type">The new type that is being mocked</param>
        </member>
        <member name="M:TypeMock.MockedTypesList.Clear">
            <summary>
            Clear The list from all mocked types
            </summary>
        </member>
        <member name="M:TypeMock.MockedTypesList.Contains(System.String)">
            <summary>
            Determines whether a specific type has been mocked. 
            </summary>
            <param name="name">the name of the type</param>
            <returns>true if the type has been mocked</returns>
        </member>
        <member name="M:TypeMock.MockedTypesList.Contains(System.Type)">
            <summary>
            Determines whether a specific type has been mocked. 
            </summary>
            <param name="Type">the type to look for</param>
            <returns>true if the type has been mocked</returns>
        </member>
        <member name="T:TypeMock.MethodExpectation">
            <summary>
            Manage all expectations set on a specific method 
            </summary>
            <remarks>
            There are two kinds of call expectations values - Default and sequenced.
            The Default is used to Always return the same value, and the sequence
            return according to call sequence, there are also two corresponding types for conditional
            and default conditional</remarks>
        </member>
        <member name="T:TypeMock.IMethodSettings">
            <summary>
            Perform Behavior tweaking on methods rather then the whole mocked type
            </summary>
            <remarks>
            <see cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            </remarks>
        </member>
        <member name="P:TypeMock.IMethodSettings.IsStrict">
            <summary>
            Can set one method of the mock to be Strict
            </summary>
            <remarks>
            By default Mocked Types are NOT strict this mean that if a call to a mocked
            method was not expected the normal code is executed.
            Mocked Types can be made strict and fail if an unexpected call is made
            <example><code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	// No expectations, the following will fail because passInt() is 
            	// set to Strict
            	mock.MethodSettings("passInt").IsStrict = true;
            	t.passInt(10);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            {
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	' No expectations, the following will fail because passInt() is 
            	' set to Strict
            	mock.MethodSettings("passInt").IsStrict = True
            	t.passInt(10)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            <seealso cref="T:TypeMock.VerifyMode"/>
            </remarks>
        </member>
        <member name="E:TypeMock.IMethodSettings.MockMethodCalled">
            <summary>
            Event that is fired after a mocked method is called and after validation is performed
            <see cref="T:TypeMock.MockMethodCalledEventHandler"/> <seealso cref="T:TypeMock.MockMethodCalledEventHandler"/>
            </summary>
            <remarks>
            To set an event for all calls see Mock.<see cref="E:TypeMock.Mock.MockMethodCalled"/>
            <example>
            <code lang="cs">
            // This will be called when a mocked method is called
            private void SuccessEvent(object sender,MockMethodCallEventArgs e) 
            {
            	Assert.AreEqual(typeof(TestedClass),e.CalledType);
            	Assert.AreEqual("getVar",e.CalledMethodName);
            	Assert.AreEqual(0,e.SentArguments.Length);
            	Assert.AreEqual(0,e.ExpectedArguments.Length);
            	Assert.AreEqual(false,e.WillThrowException);
            	Assert.AreEqual(null,e.Exception);
            	Assert.AreEqual(5,e.ReturnValue);
            	Assert.AreEqual(true,e.HasPassedValidation);
            }
            [Test]
            public void SimpleEventSuccess() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass),false);
            	TestedClass t = new TestedClass();
            	
            	mock.ExpectAndReturn("getVar",5);
            	// set event listener
            	mock.MethodSettings("getVar").MockMethodCalled += new MockMethodCalledEventHandler(SuccessEvent);
            	// the event will be called
            	Assert.AreEqual(5,t.getVar());
            	mock.Verify();
            }
            </code>
            <code lang="vbnet">
            ' This will be called when a mocked method is called
            Public Shared Sub SuccessEvent(ByVal sender As Object, ByVal e As MockMethodCallEventArgs) 
            	Assert.AreEqual(GetType(TestedClass),e.CalledType)
            	Assert.AreEqual("getVar",e.CalledMethodName)
            	Assert.AreEqual(0,e.SentArguments.Length)
            	Assert.AreEqual(0,e.ExpectedArguments.Length)
            	Assert.AreEqual(False,e.WillThrowException)
            	Assert.AreEqual(Nothing,e.Exception)
            	Assert.AreEqual(5,e.ReturnValue)
            	Assert.AreEqual(True,e.HasPassedValidation)
            End Sub
            
            &lt;Test()&gt; _
            Public Sub SimpleEventSuccess()
            	Dim t As TestedClass = new TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	
            	mock.ExpectAndReturn("getVar",5)
            	' set event listener
            	AddHandler mock.MethodSettings("getVar").MockMethodCalled, AddressOf SuccessEvent
            	
            	' the event will be called
            	Assert.AreEqual(5,t.getVar())
            	mock.Verify()
            End Sub
            </code>
            </example>
            </remarks>	
        </member>
        <member name="M:TypeMock.MethodExpectation.CreateDefault(System.Object,System.Boolean,TypeMock.Mock,TypeMock.ExpectationBlock)">
            Create a new default call expectation.
            Note - this will replace the previous default
        </member>
        <member name="M:TypeMock.MethodExpectation.AddNewCallExpectation(System.Object,System.Boolean,TypeMock.Mock)">
            Add a new regular call expectation
        </member>
        <member name="M:TypeMock.MethodExpectation.CountExpectedCallsLeft">
            <summary>
            this will count the number of calls which were not made.
            (only calls with normal verification mode are counted)
            </summary>
        </member>
        <member name="M:TypeMock.MethodExpectation.GetReturn(System.Object,System.Object[],System.Type,TypeMock.Scope,System.Int32,System.Object,System.Type)">
            <summary>
            this is the main api used during the test execution, when a method is mocked we will call this
            to "activate" the behavior which was dictated during the expectation setup phase.
            </summary>
            <returns>the value to return to the user</returns>
        </member>
        <member name="M:TypeMock.MethodExpectation.Verify">
            <summary>
            Count the number of unfulfilled expectations.
            </summary>
            <returns>number of calls left (Negative can happen with default returns)</returns>
        </member>
        <member name="M:TypeMock.MethodExpectation.MoveToProperDefault(TypeMock.CallExpectation)">
            <summary>
            this takes a regular/conditional expectation and turn it into a default regular/conditional
            (repeated always) expectation.
            </summary>
        </member>
        <member name="T:TypeMock.InstanceKey">
            <summary>
            This is to wrap all classes and use our own Hash code.
            Or else it might lead to stack overflow
            </summary>
        </member>
        <member name="P:TypeMock.InstanceKey.InstanceObject">
            <summary>
            returns the mocked object instance
            </summary>
        </member>
        <member name="T:TypeMock.NullableInstanceKey">
            <summary>
            This is to wrap all classes and use our own Hash code.
            Or else it might lead to stack overflow
            </summary>
        </member>
        <member name="P:TypeMock.NullableInstanceKey.InstanceObject">
            <summary>
            returns the mocked object instance
            </summary>
        </member>
        <member name="M:TypeMock.TypeExpectations.Verify">
            <summary>
            Verify mocked type 
            </summary>
        </member>
        <member name="M:TypeMock.TypeExpectations.FindRecorderMock(TypeMock.Mock)">
            <summary>
            Find the mock object that was created during the recording of the given mock object
            </summary>
            <param name="createdMock"></param>
            <returns></returns>
        </member>
        <member name="P:TypeMock.TypeExpectations.IsMockAllBehaviorAlreadySet">
            <summary>
            should be true only if MockAll behavior has been set for a struct through AAA
            </summary>
        </member>
        <member name="T:ThreadMessaging.SemaphoreFailedException">
            <exclude/>
        </member>
        <member name="M:ThreadMessaging.SemaphoreFailedException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.MockScope">
            <summary>Create a new instance of the MockScope that will activate the mock
            verification process on its dispose.</summary>
            <remarks>
            <example>
            <code lang="cs"> 
            [Test]
             void TestMethod1()
             {
            	using (new MockScope())
            	{
            		//The Test code
            	}
             }</code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestMethod1()
                Using Scope As New MockScope
                    ' The Test code
                End Using
            End Sub
            </code>
            </example> 
            </remarks>
        </member>
        <member name="F:TypeMock.MockScope.m_Timeout">
            <summary>
            stores the timeout to pass to verify
            </summary>
        </member>
        <member name="M:TypeMock.MockScope.#ctor">
            <summary>Create a new instance of the MockScope that will activate the mock
            verification process on its dispose.</summary>
            <remarks>
            <example>
            <code lang="cs"> 
            [Test]
             void TestMethod1()
             {
            	using (new MockScope())
            	{
            		//The Test code
            	}
             }</code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestMethod1()
                Using Scope As New MockScope
                    ' The Test code
                End Using
            End Sub
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:TypeMock.MockScope.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TypeMock.MockScope"/> class, that will call
            the VerifyWithTimeout with the given timeout.
            </summary>
            <param name="millisecondTimeout">The millisecond timeout.</param>
            <summary>Create a new instance of the MockScope that will activate the mock
            verification process on its dispose.</summary>
            <example><para></para>
            <para></para>
            <code lang="cs"> 
            [Test]
             void TestMethod1()
             {
            	using (new MockScope(1000))
            	{
            		//The Test code
            	}
             }</code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestMethod1()
                Using Scope As New MockScope(1000)
                    ' The Test code
                End Using
            End Sub
            </code>
            </example>
        </member>
        <member name="M:TypeMock.MockScope.Dispose">
            <summary>
            Activate the verification process
            </summary>
        </member>
        <member name="T:TypeMock.GlobalFunctions">
            <summary>
            Use this type when mocking global functions
            </summary>
            <remarks>
            This is an example of how to mock global functions in C++
            <example>
            <code>
            namespace TestWithCpp
            {
            	int globalFunction(int a) {return a;}
            }
            </code>
            And the test
            <code>
            [Test]
            void Global() {
            	Mock* mock = MockManager::Mock(__typeof(GlobalType));
            	mock->ExpectAndReturn("TestWithCpp.globalFunction",__box(5));
            	Assert::AreEqual(__box(5), __box(globalFunction(4)));
            }	
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:TypeMock.CallExpectation">
            <summary>
            Hold the Return value for mocked methods
            </summary>
        </member>
        <member name="T:TypeMock.IParameters">
            <summary>
            Typemock Isolator can validates parameter values, collections and arrays.
            To do so just pass the list of expected parameter values to the <c>Args</c>
            method. 
            </summary>
            <remarks>
            It is possible to check that a mocked method has been called with specific
            argument values.
            <para>
            <example>
            For example, if we need to check that an <c>int</c> parameter is 10
            we can write the following code
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	// first time passInt will be called, arguments must be 10 
            	mock.ExpectCall("passInt").Args(10);
            	// second time 1
            	mock.ExpectCall("passInt").Args(1);
            	TestedClass t = new TestedClass();
            	// This will pass 
            	t.passInt(10);
            	// This will fail 
            	t.passInt(3);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	' first time passInt will be called, arguments must be 10 
            	mock.ExpectCall("passInt").Args(10)
            	' second time 1
            	mock.ExpectCall("passInt").Args(1)
            	Dim t As TestedClass = New TestedClass
            	' This will pass 
            	t.passInt(10)
            	' This will fail 
            	t.passInt(3)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </para>
            Single Dimension Arrays and Collections are iterated and checked for match of all items
            See <see cref="T:TypeMock.Check"/> for built in ParameterCheckers 
            See <see cref="T:TypeMock.ParameterChecker"/> for details of user defined checks 
            
            <note>
            BEWARE, Typemock Isolator normally check the type of return value with the existing
            method, but it does not check the legitimacy of the returned value in case of
            overloaded methods that have different return types, (as Typemock Isolator sees these 
            as one mocked method) if you return a value with the wrong type a 
            <c>System.InvalidCastException</c> will be thrown
            </note>
            <note>
            Typemock Isolator supports checking methods with up to 30 parameters 
            </note>
            <note>
            This Interface is not to be implemented by client 
            </note>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </remarks>
        </member>
        <member name="M:TypeMock.IParameters.Args(System.Object[])">
            <summary>
            Set the list of expected parameters
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="args">list of expected parameters and/or parameter checkers</param>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if more then 30 parameters are used</exception>
        </member>
        <member name="M:TypeMock.IParameters.When(System.Object[])">
            <summary>
            Conditional mock,
            Set the list of parameters, only if these parameters are passed, is the mocked invoked
            *Enterprise version Only*
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="args">list of condition parameters and/or parameter checkers</param>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if more then 30 parameters are used</exception>
        </member>
        <member name="T:TypeMock.IPropertyParameters">
            <summary>
            Parameter Checks for mocked Property set methods
            </summary>
            <remarks>
            See <see cref="T:TypeMock.IParameters"/> and <see cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            <note>
            This Interface is not to be implemented by client 
            </note>
            </remarks>
        </member>
        <member name="M:TypeMock.IPropertyParameters.Args(System.Object)">
            <summary>
            Set expected set value
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="value">expected value</param>
        </member>
        <member name="M:TypeMock.IPropertyParameters.When(System.Object)">
            <summary>
            Conditional mock,
            Set the list of parameters, only if these parameters are passed, is the mocked invoked
            *Enterprise version Only*
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="value">conditional value</param>
        </member>
        <member name="T:TypeMock.IIndexSetParameters">
            <summary>
            Parameter Checks for mocked Index set methods
            </summary>
            <remarks>
            See <see cref="T:TypeMock.IParameters"/> and <see cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <note>
            This Interface is not to be implemented by client 
            </note>
            </remarks>
        </member>
        <member name="M:TypeMock.IIndexSetParameters.Args(System.Object,System.Object)">
            <summary>
            Set expected index number
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="index">expected index</param>
            <param name="value">expected set value</param>
        </member>
        <member name="M:TypeMock.IIndexSetParameters.When(System.Object,System.Object)">
            <summary>
            Conditional mock,
            Set the list of parameters, only if these parameters are passed, is the mocked invoked
            *Enterprise version Only*
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="index">conditional index</param>
            <param name="value">conditional set value</param>
        </member>
        <member name="T:TypeMock.IIndexGetParameters">
            <summary>
            Parameter Checks for mocked Index get methods
            </summary>
            <remarks>
            See <see cref="T:TypeMock.IParameters"/> and <see cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <note>
            This Interface is not to be implemented by client 
            </note>
            </remarks>
        </member>
        <member name="M:TypeMock.IIndexGetParameters.Args(System.Object)">
            <summary>
            Set expected index number
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <param name="index">expected index</param>
        </member>
        <member name="M:TypeMock.IIndexGetParameters.When(System.Object)">
            <summary>
            Conditional mock,
            Set the list of parameters, only if these parameters are passed, is the mocked invoked
            *Enterprise version Only*
            <seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="index">conditional index</param>
        </member>
        <member name="M:TypeMock.CallExpectation.Repeat(System.Int32)">
            <summary>
            set the number of times that the expectation should be repeated
            </summary>
            <param name="value">times to repeat</param>
        </member>
        <member name="M:TypeMock.CallExpectation.CheckAndAssign(System.Object[],System.Type)">
            <summary>
            check that the actual arguments passed to the call match the expected, and assign new values 
            if needed. method will throw a VerifyException if arguments do not match.
            </summary>
            <param name="actualParams">the real parameters passed to the call</param>
            <param name="type">the mocked type (needed for error messages)</param>
        </member>
        <member name="M:TypeMock.CallExpectation.ConditionSatisfied(System.Object[],System.Type)">
            <summary>
            this just check if actual paramaters passed to the method match the expected ones 
            (needed to decide if the method should be mocked or not)
            </summary>
            <param name="actualArgs">actual parameters passed to the call</param>
            <param name="type">the mocked type (needed for error messages)</param>
            <returns>true if condition is satisfied</returns>
        </member>
        <member name="T:TypeMock.LicenseType">
            <summary>
            Enterprise: perpetual fully featured
            Timed: time limited fully featured. Update-timebomed.
            Temp: temporary fully featured, used for the period between purchase order and actual purchase. 30 day Usage-timebombed.
            Evaluation: fully featured 21 day usage-timebombed
            Extended: fully featured 14 day usage-timebombed
            </summary>
        </member>
        <member name="M:TypeMock.Core.GetPathForSystemFiles">
            <summary>
            returns path for system files for 32/64 bit machines
            </summary>
        </member>
        <member name="M:TypeMock.Core.IsInstallingMajorVersion">
            <summary>
            In Isolator: Major version is .NET Version [Major].[Minor]
            </summary>
        </member>
        <member name="T:TypeMock.ArrangeActAssert.IHideObjectMethods">
            <summary>
            For internal use only.
            </summary>
        </member>
        <member name="T:ThreadMessaging.ProcessSemaphore">
            <exclude/>
            <summary>
            ProcessSemaphore is an Inter-Process counting semaphore using Win32 Semaphores.
            Semaphores are useful for Inter-Process synchronization and communication.
            </summary>
            <remarks>All members of this class are thread-safe.</remarks>
        </member>
        <member name="T:ThreadMessaging.ISemaphore">
            <exclude/>
            <summary>
            A counting semaphore is a thread or process synchronization primitive.
            Semaphores are useful for Inter-Thread or Inter-Process synchronization and communication, depending on the implementation.
            Usually all interfaces members of this type are thread-safe.
            </summary>
        </member>
        <member name="M:ThreadMessaging.ISemaphore.Acquire">
            <summary>
            Blocks if no release is signaled or removes a release signal. Enter a critical section.
            In theory, this method is often called P() [Dijkstra, dutch: passeeren]
            </summary>
        </member>
        <member name="M:ThreadMessaging.ISemaphore.Acquire(System.TimeSpan)">
            <summary>
            Blocks if no release is signaled or removes a release signal. Enter a critical section.
            In theory, this method is often called P() [Dijkstra, dutch: passeeren]
            </summary>
            <param name="timeout">The maximum blocking time. Usually an Exceptions is thrown if a timeout exceeds.</param>
        </member>
        <member name="M:ThreadMessaging.ISemaphore.Release">
            <summary>
            Signals a release and allows a blocked thread to continue. Leave a critical section.
            In theory, this method is often called V() [Dijkstra, dutch: vrijgeven]
            </summary>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.#ctor(System.String)">
            <summary>
            Instanciate a new Inter-Process semaphore.
            </summary>
            <param name="name">The semaphore's name.</param>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.#ctor(System.String,System.Int32)">
            <summary>
            Instanciate a new Inter-Process semaphore.
            </summary>
            <param name="name">The semaphore's name.</param>
            <param name="initial">The initial count of releases signaled.</param>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Instanciate a new Inter-Process semaphore.
            </summary>
            <param name="name">The semaphore's name.</param>
            <param name="initial">The initial count of releases signaled.</param>
            <param name="max">The maximum count of release signaled.</param>
            <param name="interruptReactionTime">The maximum time [ms] needed to react to interrupts.</param>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.Acquire">
            <summary>
            Blocks if no release is signaled or removes a release signal. Enter a critical section.
            In theory, this method is often called P() [Dijkstra, dutch: passeeren]
            </summary>
            <remarks>This member is thread-safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.Acquire(System.TimeSpan)">
            <summary>
            Blocks if no release is signaled or removes a release signal. Enter a critical section.
            In theory, this method is often called P() [Dijkstra, dutch: passeeren]
            </summary>
            <param name="timeout">The maximum blocking time. Usually an Exceptions is thrown if a timeout exceeds.</param>
            <remarks>This member is thread-safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.Release">
            <summary>
            Signals a release and allows a blocked thread to continue. Leave a critical section.
            In theory, this method is often called V() [Dijkstra, dutch: vrijgeven]
            </summary>
            <remarks>This member is thread-safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessSemaphore.Dispose">
            <summary>
            Don't forget to dispose this object before destruction.
            </summary>
        </member>
        <member name="T:ThreadMessaging.MemoryMappedQueue">
            <exclude/>
            <remarks>All members are neither thread-safe nor process-safe! It's up to you to synchronize access.</remarks>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedQueue.#ctor(ThreadMessaging.MemoryMappedFileView,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Instanciate a new memory mapped array for inter-process access.
            </summary>
            <param name="view">The memory mapped file view.</param>
            <param name="length">The count of entries of the array.</param>
            <param name="bytesPerEntry">The (maximal) count of bytes per entry.</param>
            <param name="cooperative">
            If true, it accepts other length and bytesPerEntry if the array already exists.
            If falls it throws an exception if the array already exists but with other length or bytesPerEntry.
            </param>
            <param name="offset">An optional initial positive offset before the array starts.</param>
        </member>
        <member name="T:ThreadMessaging.MemoryMappedArray">
            <exclude/>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedArray.#ctor(ThreadMessaging.MemoryMappedFileView,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Instanciate a new memory mapped array for inter-process access.
            </summary>
            <param name="view">The memory mapped file view.</param>
            <param name="length">The count of entries of the array.</param>
            <param name="bytesPerEntry">The (maximal) count of bytes per entry.</param>
            <param name="cooperative">
            If true, it accepts other length and bytesPerEntry if the array already exists.
            If falls it throws an exception if the array already exists but with other length or bytesPerEntry.
            </param>
            <param name="offset">An optional initial positive offset before the array starts.</param>
            <remarks>All members are neither thread-safe nor process-safe! It's up to you to synchronize access.</remarks>
        </member>
        <member name="T:TypeMock.MockedEvent">
             <summary>
             MockedEvent is used to validate firing of events.
             <para>
             To use this an event must be mocked first, and then the test can fire that event to test that the correct methods are actually called.
             </para>
             </summary>
             <remarks>
             <para>
             When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance"/>[index] property
             The first instance to register to the event will be in index 0, the next instance in 1 and so on.
             </para>
             <para>
             <example>
             Example of one instance of Button having the Click event mocked. We will fire the event to test that our TestedClass
             event handler is called
             <code lang="cs">
             // Part of tested class
             public void Init()
             {
                Button button = new Button();
                button.Click += new EventHandler(button_Click);
             }
             </code>
             <code lang="vbnet">
             Public Sub Init()
                Dim button As Button = New Button
                AddHandler button.Click, AddressOf button_Click
             End Sub
             </code>
             Here is the test
             <code lang="cs">
             [Test]
             public void Test()
             {
                 // we will mock the Click event and save the MockedEvent
                 Mock buttonMock = MockManager.Mock(typeof(Button));
                 MockedEvent buttonHandle = buttonMock.ExpectAddEvent("Click");
                             
                 // we expect button_Click to be called once (when the button is clicked)
                 Mock testedMock = MockManager.Mock(typeof(TestedClass));
                 testedMock.ExpectCall("button_Click");
             
                 // call our code
                 TestedClass test = new TestedClass();
                 test.Init();
             
                 // emulate click.
                 buttonHandle.Fire(this, EventArgs.Empty);
                     
                 // verify that all calls where made
                 MockManager.Verify();
             }
             // Natural Mocks
             [Test]
             public void Test()
             {
                 MockedEvent buttonHandle;
            		// Start mocking 
                 using (RecordExpectations recorder = RecorderManager.StartRecording())
                 {
                    // we will mock the Click event and save the MockedEvent
                    Button buttonMock = new Button();
                    buttonMock.Click += null;
                    buttonHandle = RecorderManager.LastMockedEvent;
            
                    // we expect button_Click to be called once (when the button is clicked)
                    TestedClass testMock = new TestedClass();
                    testMock.button_Click(null,null); // use Reflective Mocks if this is private 
                 }
             
                 // call our code
                 TestedClass test = new TestedClass();
                 test.Init();
             
                 // emulate click.
                 buttonHandle.Fire(this, EventArgs.Empty);
                     
                 // verify that all calls where made
                 MockManager.Verify();
             }
             </code>
             <code lang="vbnet">
             &lt;Test()&gt; _
             Public Sub Test()
                 ' we will mock the Click event and save the MockedEvent 
                 Dim buttonMock As Mock = MockManager.Mock(GetType(Button))
                 Dim buttonHandle As MockedEvent = buttonMock.ExpectAddEvent("Click")
             
                 ' we expect button_Click to be called once (when the button is clicked)
                 Dim testedMock As Mock = MockManager.Mock(GetType(TestedClass))
                 testedMock.ExpectCall("button_Click")
             
                 ' call our code
                  Dim test As New TestedClass
                  test.Init()
             
                  ' emulate click.
                  buttonHandle.Fire(Me, EventArgs.Empty)
                  ' Verify that all calls were made 
                  MockManager.Verify()
            	End Sub
             
             ' .NET 2.0 Natural Mocks
             &lt;Test()&gt; _
             Public Sub Test()
                Dim buttonHandle As MockedEvent
                Dim test As New TestedClass
                Using recorder As New RecordExpectations
                   ' mock the Click event and save the MockedEvent 
                   Dim buttonMock As Button = New Button()
                   AddHandler buttonMock.Click, AddressOf test.button_Click
                   buttonHandle = RecorderManager.LastMockedEvent
                   
                   ' we expect button_Click to be called once (when the button is clicked)
                   testMock.button_Click(Nothing, Nothing) ' use Reflective Mocks if this is private 
                 End Using   
             
                  ' call our code
                  test.Init()
             
                  ' emulate click.
                  buttonHandle.Fire(Me, EventArgs.Empty)
                  ' Verify that all calls were made 
                  MockManager.Verify()
            	End Sub    
             </code>
             For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
             </example>
             </para>
             Since Version 3.6
             </remarks>
        </member>
        <member name="T:TypeMock.IMockedEvent">
            <summary>
            IMockedEvent is the Typemock Isolator Event Mocking mechanism, used to fire events to test Event driven applications.
            </summary>
            <remarks>
            <para>
            When one instance of the event publisher is mocked, use MockedEvent.<see cref="M:TypeMock.MockedEvent.Fire(System.Object[])"/> 
            to fire the event.
            <code lang="cs">
            [Test]
            public void SimulateFiringClick()
            {
              // Mock the Click Event of the next Button
              Mock mockButton = MockManager.Mock(typeof(Button));
              MockedEvent handler = mockButton.ExpectAddEvent("Click");
            
              // Create the button and register to the Event
              Button button = new(Button);
              button.Click += new EventHandler(button_Click);
            
              // Simulate firing the event
              handler.Fire(this, EventArgs.Empty);
              // Check that system works...
            
              MockManager.Verify()
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClick()
              'Mock all Click Events of the next Button
              Dim buttonMock As Mock = MockManager.Mock(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEvent("Click")
            
              ' Create the button and register to the Event
              Dim button As Button = New Button
              AddHandler button.Click, AddressOf button_Click
            
              ' Simulate firing the event
              handle.Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>  /// 
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance"/>[index] property
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>
            </para>
            Since Version 3.7
            </remarks>
        </member>
        <member name="M:TypeMock.IMockedEvent.Fire(System.Object[])">
            <summary>
            Fire a mocked event. See <see cref="T:TypeMock.IMockedEvent"/>
            </summary>
            <param name="args">Arguments to pass to the mocked event</param>
            <returns>The return value of the event</returns>
        </member>
        <member name="M:TypeMock.IMockedEvent.GetEventHandle">
            <summary>
            Retrieve the EventHandle
            </summary>
            <remarks>
            Using GetEventHandle can help write type-safe tests by casting the EventHandle to the correct Event Type
            Example
            <code lang="cs">
            EventHandler fire = handle.GetEventHandle() as EventHandler;
            fire(this, EventArgs.Empty);
            </code>
            <code lanf="vbnet">
            Dim fire As EventHandler = handle.GetEventHandle()
            fire(Me, EventArgs.Empty)
            </code>
            </remarks>
            <returns>The Event</returns>
        </member>
        <member name="F:TypeMock.MockedEvent.keepReturnValues">
            <summary>
            Used to get return values for NaturalMocks, so that we can do recorder.Repeat
            </summary>
        </member>
        <member name="M:TypeMock.MockedEvent.Fire(System.Object[])">
            <summary>
            Fire a mocked event
            </summary>
            <param name="args">Arguments to pass to the mocked event</param>
            <returns>The return value of the event</returns>
        </member>
        <member name="M:TypeMock.MockedEvent.GetEventHandle">
            <summary>
            Retrieve the EventHandle
            </summary>
            <remarks>
            Using GetEventHandle can help write type-safe tests by casting the EventHandle to the correct Event Type
            Example
            <code lang="cs">
            EventHandler fire = handle.GetEventHandle() as EventHandler;
            fire(this, EventArgs.Empty);
            </code>
            <code lang="vbnet">
            Dim fire As EventHandler = handle.GetEventHandle()
            fire(Me, EventArgs.Empty)
            </code>
            </remarks>
            <returns>The Event</returns>
        </member>
        <member name="P:TypeMock.MockedEvent.Instance">
            <summary>
            Retrieve the <see cref="T:TypeMock.IMockedEvent"/> when more than one instance of the event published is mocked
            <para>
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            This is used to simulate firing the event.
            </para>
            </summary>
            <remarks>
            <example>
            Following is an example of 2 Buttons whose Click event is mocked. The test will fire both Buttons one after
            the other.
            <code lang="cs">
            [Test]
            public void SimulateFiringClickOnManyButtons()
            {
              // Mock all Click Events of the all Buttons
              Mock buttonMock = MockManager.MockAll(typeof(Button)); 
              MockedEvent handle = buttonMock.ExpectAddEventAlways("Click");
            
              // create 2 buttons and register to the Click Event
              Button button1 = new Button();
              Button button2 = new Button();
              button1.Click += new EventHandler(button_Click);
              button2.Click += new EventHandler(button_Click);
            
              // Simulate firing Click of button1
              handle.Instance[0].Fire(this, EventArgs.Empty);
              // Simulate firing Click of button2
              handle.Instance[1].Fire(this, EventArgs.Empty);
              // Check that system works...
              
              MockManager.Verify()
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub SimulateFiringClickOnManyButtons()
              'Mock all Click Events of the all Buttons
              Dim buttonMock As Mock = MockManager.MockAll(GetType(Button))
              Dim handle As MockedEvent = buttonMock.ExpectAddEventAlways("Click")
            
              ' create 2 buttons and register to the Click Event
              Dim button1 As Button = New Button
              Dim button2 As Button = New Button
            
              AddHandler button1.Click, AddressOf button_Click
              AddHandler button2.Click, AddressOf button_Click
            
              ' Simulate firing Click of button1
              handle.Instance(0).Fire(Me, EventArgs.Empty)
              ' Simulate firing Click of button2
              handle.Instance(1).Fire(Me, EventArgs.Empty)
              ' Check that system works...
            
              MockManager.Verify()
            End Sub
            </code>
            </example>
            Since Version 3.7
            </remarks>
        </member>
        <member name="P:TypeMock.MockedEvent.InstanceCount">
            <summary>
            Return the number of instances registered to this mocked event. See <see cref="P:TypeMock.MockedEvent.Instance"/> 
            </summary>
            <remarks>
            Since version 3.7
            </remarks>
        </member>
        <member name="M:TypeMock.Internal.Reflection.IsNullable(System.Type)">
            <summary>
            chek to see if type can be assigned a null value
            </summary>
            <param name="type">the given type</param>
            <returns>true if type can be assigned a null value, false if not</returns>
        </member>
        <member name="M:TypeMock.Internal.Reflection.InstanceMethodExists(System.Type,System.String)">
            <summary>
            check if there is a method of the given name on this type
            (for now will also check for static methods)
            </summary>
            <param name="type"></param>
            <param name="methodName"></param>
            <returns>true if there is at least one method by that name</returns>
        </member>
        <member name="M:TypeMock.Internal.Reflection.StaticMethodExists(System.Type,System.String)">
            <summary>
            check to see if there is a STATIC method on the given type
            </summary>
            <param name="type">the type </param>
            <param name="methodName">the method name</param>
            <returns>true if there is at least one method method</returns>
        </member>
        <member name="M:TypeMock.Internal.Reflection.FindInstanceMethod(System.Type,System.String)">
            <summary>
            locate a method with the given name on the type 
            (for now consider static method as well)
            </summary>
            <param name="type">the given type</param>
            <param name="methodName">the method name</param>
            <returns>a MethodBase object representing the first found method</returns>
            <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
        </member>
        <member name="M:TypeMock.Internal.Reflection.FindStaticMethod(System.Type,System.String)">
            <summary>
            locate a STATIC method with the given name on the type
            </summary>
            <param name="type">the given type</param>
            <param name="methodName">the method name</param>
            <returns>a MethodBase object representing the first found method</returns>
            <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
        </member>
        <member name="M:TypeMock.Internal.Reflection.FindInstanceMethod(System.Type,System.String,System.Type,System.Type[])">
            <summary>
            search for a method answering all the given criteria:
              name
              generic method signature (e.g. SomemMthod[X,Y])
              Matching return type (can be void also)
            For now will incldue static method in its search.
            </summary>
            <param name="type">the given type</param>
            <param name="methodName">the method name</param>
            <param name="returnType">the supplied return type </param>
            <param name="genericTypes">the generic signature list</param>
            <returns>a MethodBase for a method answering all of the above conditions</returns>
            <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
        </member>
        <member name="M:TypeMock.Internal.Reflection.FindStaticMethod(System.Type,System.String,System.Type,System.Type[])">
            <summary>
            search for a STATIC method answering all the given criteria:
              name
              generic method signature (e.g. SomemMthod[X,Y])
              Matching return type (can be void also)
            </summary>
            <param name="type">the given type</param>
            <param name="methodName">the method name</param>
            <param name="returnType">the supplied return type </param>
            <param name="genericTypes">the generic signature list</param>
            <returns>a MethodBase for a method answering all of the above conditions</returns>
            <exception cref="T:TypeMock.TypeMockException"> if no matching method is found</exception>
        </member>
        <member name="M:TypeMock.Internal.Reflection.ConstructClosedType(System.Type,System.Type[],System.Type[])">
            <summary>
            Constructs a completely bounded type.
            </summary>
            <param name="genericType">he given type we need to constructs</param>
            <param name="methodGenericArguments">the generic arguments from the associated call</param>
            <param name="classGenericArguments">the generic arguments from the associated class</param>
            <returns>a fully binded type</returns>
        </member>
        <member name="M:TypeMock.Internal.Reflection.GetBoundedRuntimeType(System.Object,System.Reflection.MethodInfo)">
            <summary>
            This will return the bounded generic type in which the method is declared
            this can either be the type of the context instance, or one of his ancestors types
            </summary>
            <param name="context">the instance on which the call was made</param>
            <param name="info">the method call data</param>
            <returns>The vounded type on which the call was made </returns>
        </member>
        <member name="M:TypeMock.Internal.Reflection.GetTypeGenericArguments(System.Object,System.Reflection.MethodInfo)">
            <summary>
            This returns the generic arguments of the type associated with the call.
            i.e. the bounded type on which the call was issued
            </summary>
            <param name="context">this either contains the instance on which the call was made, 
            the TypeParams of the class in cases of generic static calls or null (regular static calls)</param>
            <param name="info">the call method</param>
            <returns></returns>
        </member>
        <member name="M:TypeMock.Internal.Reflection.MatchReturnArgument(System.Collections.Generic.List{System.Reflection.MethodInfo},System.Type,System.Type[],System.Type@)">
            <summary>
            Filter out the methods with matching return types 
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.GetMethodMatchingGenericDefinition(System.Collections.Generic.List{System.Reflection.MethodInfo},System.Type[])">
            <summary>
            Filter out the methods with matching generic signature
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.GetInstanceMethods(System.Object[])">
            <summary>
            Filter out static methods returning only instance methods
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.GetStaticMethods(System.Collections.Generic.List{System.Reflection.MethodInfo})">
            <summary>
            Filter out instance methods returning only instance methods
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.FindTypeInGivenList(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            will find the m ethod return type in the generic signature
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.TypeMatches(System.Type,System.Type)">
            <summary>
            return true if the types matches according to our logic:
                1) DynamicReturnValue always match
                2) if user gave a null value we match if the method return type can be assigne da null value
                3) do a smart generic matching bound generic types
                4) unbound generic types always match
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.MatchGenericTypes(System.Type,System.Type)">
            <summary>
            do smart match of for a generic type by comparing the generic type definition
            to the generic type definiton of the other class along with his entire class hirarchy or implemented interfaces 
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.FindMethodsByName(System.Type,System.String)">
            <summary>
            collect all methods on the type any of his base class or implemented interfaces with the given name
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.GenericString(System.Type[])">
            <summary>
            convert the type list into a nice presentable string
            </summary>
        </member>
        <member name="M:TypeMock.Internal.Reflection.BuildException(System.String,System.String,System.Type,System.Collections.Generic.List{System.Reflection.MethodInfo},System.Type)">
            <summary>
            build a smart exception string based on the scenario
            </summary>
        </member>
        <member name="T:TypeMock.Check">
            <summary>
            This class provides built in Parameter Checkers. See <see cref="T:TypeMock.ParameterChecker"/>
            and <see cref="T:TypeMock.IParameters"/>
            </summary>
            <remarks>
            Following is an example of using the build in IsNull Check
            <example>
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.IsNull(),null);
            	t.SomeMethod(null,null);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock  = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	mock.ExpectCall("SomeMethod").Args(Check.IsNull(),Nothing)
            	t.SomeMethod(Nothing,Nothing)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            </remarks>
        </member>
        <member name="M:TypeMock.Check.IsNull">
            <summary>
            Check that parameter is null, this is equivalent to passing null
            </summary>
            <remarks>
            <example>
            Here is an example of how to use IsNull
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.IsNull(),null);
            	t.SomeMethod(null,null);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	mock.ExpectCall("SomeMethod").Args(Check.IsNull(),Nothing)
            	t.SomeMethod(Nothing,Nothing)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <returns>IsNull ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsNull(System.String)">
            <summary>
            Check that parameter is null, with custom error message (see <see cref="M:TypeMock.Check.IsNull"/>)
            </summary>
            <param name="message">Custom Error Message</param>
            <returns>IsNull ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsNull(System.String,System.Object[])">
            <summary>
            Check that parameter is null, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsNull"/>)
            </summary>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsNull ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsAny">
            <summary>
            Allow any parameter value (Doesn't check parameter)
            </summary>
            <remarks>
            Here is an example of how to use IsAny
            <example>
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.IsAny());
            	t.SomeMethod("Anything");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	mock.ExpectCall("SomeMethod").Args(Check.IsAny())
            	t.SomeMethod("Anything")
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <returns>IsAny ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsTypeOf(System.Type)">
            <summary>
            Check that parameter is of the passed type
            </summary>
            <remarks>
            Check that parameter is the passed type, extends the passed type, or implements the passed type
            <example>
            Here is an example of how to use IsTypeOf
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.IsTypeOf(typeof(string)));
            	t.SomeMethod("Anything");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	mock.ExpectCall("SomeMethod").Args(Check.IsTypeOf(GetType(String)))
            	t.SomeMethod("Anything")
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="theType">The type that we expect to be passed</param>
            <returns>IsTypeOf ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsTypeOf(System.Type,System.String)">
            <summary>
            Check that parameter is of the passed type, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsTypeOf(System.Type)"/>)
            </summary>
            <param name="theType">The type that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>IsTypeOf ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsTypeOf(System.Type,System.String,System.Object[])">
            <summary>
            Check that parameter is of the passed type, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsTypeOf(System.Type)"/>)
            </summary>
            <param name="theType">The type that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsTypeOf ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsTypeOf``1">
            <summary>
            Check that parameter is of the passed type.
            </summary>
            <returns>AreSameType ParameterChecker</returns>
            <remarks>
            This is code sugar and is equivalent to <see cref="M:TypeMock.Check.IsTypeOf(System.Type)"/>
            <example>
            <code>
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = Mock&lt;TestedClass&gt;.MockNextInstance();
            	mock.ExpectCall("SomeMethod").Args(Check&lt;int&gt;.AreSameType());
            
            	TestedClass test = new TestedClass();
            	test.SomeMethod(5);
            	MockManager.Verify();
            }
            </code>
            <code lang="VB">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock  = Mock(Of TestedClass).MockNextInstance()
            	mock.ExpectCall("SomeMethod").Args(Check(Of Integer)).AreSameType())
            
            	Dim test As TestedClass = New TestedClass
            	test.SomeMethod(5)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:TypeMock.Check.IsTypeOf``1(System.String,System.Object[])">
            <summary>
            Check that parameter is of the passed type with custom error message and arguments for message (see <see cref="!:AreSameType()"/>)
            </summary>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>AreSameType ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsEqual(System.Object)">
            <summary>
            Check that parameter is equal to expected value, this is equivalent to calling the expected object Equals method.
            </summary>
            <remarks>
            Single Dimension Arrays and Collections are iterated and checked for match of all items
            <example>
            Here is an example of how to use IsEqual
            <code lnag="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.IsEqual("String"),"Another"));
            	t.SomeMethod("String","Another");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	mock.ExpectCall("SomeMethod").Args(Check.IsEqual("String"),"Another")))
            	t.SomeMethod("String","Another")
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The value that we expect to be passed</param>
            <returns>IsEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsEqual(System.Object,System.String)">
            <summary>
            Check that parameter is equal to expected value, this is equivalent to calling the expected object Equals method, with custom error message (see <see cref="M:TypeMock.Check.IsEqual(System.Object)"/>)
            </summary>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>IsEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsEqual(System.Object,System.String,System.Object[])">
            <summary>
            Check that parameter is equal to expected value, this is equivalent to calling the expected object Equals method, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsEqual(System.Object)"/>)
            </summary>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)">
            <summary>
            Call Custom Parameter Checker and send the expected value to the delegate
            This will set <see cref="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue"/>
            </summary>
            <remarks>
            <example>
            Here is an example of how to use CustomChecker
            <code lang="cs">
            public static bool CheckParameter(ParameterCheckerEventArgs data)
            {
            	return data.ArgumentValue == data.ExpectedValue;
            }
            
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
                // setup expectation, test first argument by calling our CheckParameter
                // with ExpectedValue set
            	mock.ExpectCall("SomeMethod").Args(Check.CustomChecker(new ParameterCheckerEx(CheckParameter),"String")));
            	t.SomeMethod("String");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            Public Shared Function CheckParameter(ByVal data As ParameterCheckerEventArgs) As Boolean
            	CheckParameter = data.ArgumentValue = data.ExpectedValue;
            End Function
            
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
                ' setup expectation, test first argument by calling our CheckParameter
                ' with ExpectedValue set
            	mock.ExpectCall("SomeMethod").Args(Check.CustomChecker(New ParameterCheckerEx(AddressOf CheckParameter),"String"))
            	t.SomeMethod("String")
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <seealso cref="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue"/>
            <param name="checker">The custom parameter checker</param>
            <param name="expected">The value that we expect to be passed</param>
            <returns>CustomChecker ParameterCheckerEx</returns>
        </member>
        <member name="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object,System.String)">
            <summary>
            Call Custom Parameter Checker and send the expected value to the delegate, with custom error message (see <see cref="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)"/>)
            This will set <see cref="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue"/>
            </summary>
            <seealso cref="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue"/>
            <param name="checker">The custom parameter checker</param>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>IsEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object,System.String,System.Object[])">
            <summary>
            Call Custom Parameter Checker and send the expected value to the delegate, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)"/>)
            This will set <see cref="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue"/>
            </summary>
            <seealso cref="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue"/>
            <param name="checker">The custom parameter checker</param>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsSame(System.Object)">
            <summary>
            Check that parameter is referencing the same object as the expected object.
            </summary>
            <remarks>
            <example>
            Here is an example of how to use IsSame
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	object pass = new object();
            	mock.ExpectCall("SomeMethod").Args(Check.IsSame(pass),"Another"));
            	t.SomeMethod(pass,"Another");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	Dim pass As Object = New Object
            	mock.ExpectCall("SomeMethod").Args(Check.IsSame(pass),"Another")))
            	t.SomeMethod(pass,"Another")
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The object that we expect to be passed</param>
            <returns>IsSame ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsSame(System.Object,System.String)">
            <summary>
            Check that parameter is referencing the same object as the expected object, with custom error message (see <see cref="M:TypeMock.Check.IsSame(System.Object)"/>)
            </summary>
            <param name="expected">The object that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>IsSame ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsSame(System.Object,System.String,System.Object[])">
            <summary>
            Check that parameter is referencing the same object as the expected object, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsSame(System.Object)"/>)
            </summary>
            <param name="expected">The object that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsSame ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsIn(System.Object[])">
            <summary>
            Check that parameter is equal to one of the items expected 
            </summary>
            <remarks>
            <example>
            Here is an example of how to use IsIn
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.IsIn("String","Another"));
            	t.SomeMethod("String");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	Dim pass As Object = New Object
            	mock.ExpectCall("SomeMethod").Args(Check.IsIn("String","Another"))
            	t.SomeMethod("String")
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The values that we expect to be passed</param>
            <returns>IsIn ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.Not(System.Object)">
            <summary>
            Reverse argument checks
            </summary>
            <remarks>
            <example>
            Here is an example of how to use Not
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.Not("Another"));
            	t.SomeMethod("String");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	Dim pass As Object = New Object
            	mock.ExpectCall("SomeMethod").Args(Check.Not("Another"))
            	t.SomeMethod("String")
            	MockManager.Verify()
            End Sub
            </code>		
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expectation">The values/Parameter checkers that we expect not to be passed</param>
            <returns>Not ParameterChecker</returns>		
        </member>
        <member name="M:TypeMock.Check.Not(System.Object,System.String)">
            <summary>
            Reverse argument checks, with custom error message (see <see cref="M:TypeMock.Check.Not(System.Object)"/>)
            </summary>
            <param name="expectation">The values/Parameter checkers that we expect not to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>Not ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.Not(System.Object,System.String,System.Object[])">
            <summary>
            Reverse argument checks, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.Not(System.Object)"/>)
            </summary>
            <param name="expectation">The values/Parameter checkers that we expect not to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>Not ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.Or(System.Object,System.Object)">
            <summary>
            Check that argument is one of the given values/checks
            </summary>
            <remarks>
            <example>
            Here is an example of how to use Or
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.Or("Another",Checks.Equal("String")));
            	t.SomeMethod("String");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	Dim pass As Object = New Object
            	mock.ExpectCall("SomeMethod").Args(Check.Or("Another"),Checks.Equal("String")))
            	t.SomeMethod("String")
            	MockManager.Verify()
            End Sub
            </code>		
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="leftExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="rightExpectation">values/Parameter checkers that we expect to be passed</param>
            <returns>Or ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.Or(System.Object,System.Object,System.String)">
            <summary>
            Check that argument is one of the given values/checks, with custom error message (see <see cref="M:TypeMock.Check.Or(System.Object,System.Object)"/>)
            </summary>
            <param name="leftExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="rightExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>Or ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.Or(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            Check that argument is one of the given values/checks, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.Or(System.Object,System.Object)"/>)
            </summary>
            <param name="leftExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="rightExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>Or ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.And(System.Object,System.Object)">
            <summary>
            Check that argument is both of the given values/checks
            </summary>
            <remarks>
            <example>
            Here is an example of how to use And
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("SomeMethod").Args(Check.And("String",Checks.IsTypeOf(typeof(String))));
            	t.SomeMethod("String");
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim mock As Mock MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	Dim pass As Object = New Object
            	mock.ExpectCall("SomeMethod").Args(Check.And("String"),Checks.IsTypeOf(GetType(String))))
            	t.SomeMethod("String")
            	MockManager.Verify()
            End Sub
            </code>		
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="leftExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="rightExpectation">values/Parameter checkers that we expect to be passed</param>
            <returns>And ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.And(System.Object,System.Object,System.String)">
            <summary>
            Check that argument is both of the given values/checks, with custom error message (see <see cref="M:TypeMock.Check.And(System.Object,System.Object)"/>)
            </summary>
            <param name="leftExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="rightExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>And ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.And(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            Check that argument is both of the given values/checks, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.And(System.Object,System.Object)"/>)
            </summary>
            <param name="leftExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="rightExpectation">values/Parameter checkers that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>And ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.NotEqual(System.Object)">
            <summary>
            Check that argument not equal to the given value, this is the same as Not(IsEqual(expected))
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expectation">Value that we expect not to be passed</param>
            <returns>NotEqual ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.NotEqual(System.Object,System.String)">
            <summary>
            Check that argument not equal to the given value, with custom error message (see <see cref="M:TypeMock.Check.NotEqual(System.Object)"/>)
            </summary>
            <param name="expectation">Value that we expect not to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>NotEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.NotEqual(System.Object,System.String,System.Object[])">
            <summary>
            Check that argument not equal to the given value, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.NotEqual(System.Object)"/>)
            </summary>
            <param name="expectation">Value that we expect not to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>NotEqual ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.NotNull">
            <summary>
            Check that argument is not null, this is the same as Not(IsNull())
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <returns>NotNull ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.NotNull(System.String)">
            <summary>
            Check that argument not null, with custom error message (see <see cref="M:TypeMock.Check.NotNull"/>)
            </summary>
            <param name="message">Custom Error Message</param>
            <returns>NotNull ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.NotNull(System.String,System.Object[])">
            <summary>
            Check that argument not null, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.NotNull"/>)
            </summary>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>NotNull ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.NotIn(System.Object[])">
            <summary>
            Check that argument is not in the provided list, this is the same as Not(IsIn(expected))
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The values that we expect not to be passed</param>
            <returns>NotNull ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.IsEqualIgnoreCase(System.String)">
            <summary>
            Check that argument is equal to expected string, ignoring case
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The value that we expect to be passed</param>
            <returns>IsEqualIgnoreCase ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.IsEqualIgnoreCase(System.String,System.String)">
            <summary>
            Check that argument is equal to expected string, ignoring case, with custom error message with (see <see cref="M:TypeMock.Check.IsEqualIgnoreCase(System.String)"/>)
            </summary>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>IsEqualIgnoreCase ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsEqualIgnoreCase(System.String,System.String,System.Object[])">
            <summary>
            Check that argument is equal to expected string, ignoring case, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsEqualIgnoreCase(System.String)"/>)
            </summary>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsEqualIgnoreCase ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsEqualIgnoreWhiteSpace(System.String)">
            <summary>
            Check that argument is equal to expected string, ignoring white spaces
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The value that we expect to be passed</param>
            <returns>IsEqualIgnoreWhiteSpace ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.IsEqualIgnoreWhiteSpace(System.String,System.String)">
            <summary>
            Check that argument is equal to expected string, ignoring white spaces, with custom error message (see <see cref="M:TypeMock.Check.IsEqualIgnoreWhiteSpace(System.String)"/>)
            </summary>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>IsEqualIgnoreWhiteSpace ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsEqualIgnoreWhiteSpace(System.String,System.String,System.Object[])">
            <summary>
            Check that argument is equal to expected string, ignoring white spaces, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsEqualIgnoreWhiteSpace(System.String)"/>)
            </summary>
            <param name="expected">The value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsEqualIgnoreWhiteSpace ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.StartsWith(System.String)">
            <summary>
            Check that argument starts with expected string,
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The start of the value that we expect to be passed</param>
            <returns>StartsWith ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.StartsWith(System.String,System.String)">
            <summary>
            Check that argument starts with expected string, with custom error message (see <see cref="M:TypeMock.Check.StartsWith(System.String)"/>)
            </summary>
            <param name="expected">The start of the value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>StartsWith ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.StartsWith(System.String,System.String,System.Object[])">
            <summary>
            Check that argument starts with expected string, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.StartsWith(System.String)"/>)
            </summary>
            <param name="expected">The start of the value that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>StartsWith ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.EndsWith(System.String)">
            <summary>
            Check that argument ends with expected string,
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The end of the string that we expect to be passed</param>
            <returns>EndsWith ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.EndsWith(System.String,System.String)">
            <summary>
            Check that argument ends with expected string, with custom error message (see <see cref="M:TypeMock.Check.StartsWith(System.String)"/>)
            </summary>
            <param name="expected">The end of the string that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <returns>EndsWith ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.EndsWith(System.String,System.String,System.Object[])">
            <summary>
            Check that argument ends with expected string, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.StartsWith(System.String)"/>)
            </summary>
            <param name="expected">The end of the string that we expect to be passed</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>EndsWith ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsMatch(System.Text.RegularExpressions.Regex)">
            <summary>
            Check that argument matches the expected regular expression,
            </summary>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="regex">The regular expression the we expect the passed string to match</param>
            <returns>IsMatch ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.IsMatch(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Check that argument matches the expected regular expression, with custom error message (see <see cref="M:TypeMock.Check.IsMatch(System.Text.RegularExpressions.Regex)"/>)
            </summary>
            <param name="regex">The regular expression the we expect the passed string to match</param>
            <param name="message">Custom Error Message</param>
            <returns>IsMatch ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsMatch(System.Text.RegularExpressions.Regex,System.String,System.Object[])">
            <summary>
            Check that argument matches the expected regular expression, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsMatch(System.Text.RegularExpressions.Regex)"/>)
            </summary>
            <param name="regex">The regular expression the we expect the passed string to match</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsMatch ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsCloseTo(System.Double,System.Double)">
            <summary>
            Check that argument is equal to the expected value with a fault tolerance provided
            </summary>
            <remarks>The value will be checked to be in between expected +/- tolerance </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="expected">The expected value</param>
            <param name="tolerance">A tolerance that we will pass</param>
            <returns>IsCloseTo ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.IsCloseTo(System.Double,System.Double,System.String)">
            <summary>
            Check that argument is equal to the expected value with a fault tolerance provided, with custom error message (see <see cref="M:TypeMock.Check.IsCloseTo(System.Double,System.Double)"/>)
            </summary>
            <param name="expected">The expected value</param>
            <param name="tolerance">A tolerance that we will pass</param>
            <param name="message">Custom Error Message</param>
            <returns>IsCloseTo ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsCloseTo(System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Check that argument is equal to the expected value with a fault tolerance provided, with custom error message and arguments for message (see <see cref="M:TypeMock.Check.IsCloseTo(System.Double,System.Double)"/>)
            </summary>
            <param name="expected">The expected value</param>
            <param name="tolerance">A tolerance that we will pass</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsCloseTo ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsMock(TypeMock.Mock)">
            <summary>
            Check that argument is a mocked types that is controlled by mock
            </summary>
            <remarks>
            <example>
            Here is an example of how to use And
            <code lang="cs">
            [Test]
            public void CheckParameters() 
            {
            	Mock passedMock = MockManager.Mock(typeof(ArgumentClass));
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	mock.ExpectCall("PassArgument").Args(Check.IsMock(passedMock));
            	t.PassArgument(new ArgumentClass());
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckParameters()
            	Dim passedMock As Mock = MockManager.Mock(GetType(ArgumentClass))
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	Dim pass As Object = New Object
            	mock.ExpectCall("PassArgument").Args(Check.IsMock(passedMock))
            	t.PassArgument(new ArgumentClass)
            	MockManager.Verify()
            End Sub
            </code>		
            </example>
            </remarks>
            <seealso cref="T:TypeMock.ParameterChecker"/><seealso cref="T:TypeMock.IParameters"/>
            <param name="mock">The mock that the expected parameter is controlling</param>
            <returns>IsMock ParameterChecker</returns>	
        </member>
        <member name="M:TypeMock.Check.IsMock(TypeMock.Mock,System.String)">
            <summary>
            Check that argument is a mocked types that is controlled by mock
            </summary>
            <param name="mock">The mock that the expected parameter is controlling</param>
            <param name="message">Custom Error Message</param>
            <returns>IsCloseTo ParameterChecker</returns>
        </member>
        <member name="M:TypeMock.Check.IsMock(TypeMock.Mock,System.String,System.Object[])">
            <summary>
            Check that argument is a mocked types that is controlled by mock
            </summary>
            <param name="mock">The mock that the expected parameter is controlling</param>
            <param name="message">Custom Error Message</param>
            <param name="args">Arguments for error message</param>
            <returns>IsCloseTo ParameterChecker</returns>
        </member>
        <member name="T:TypeMock.VerifyException">
            <summary>
            VerifyException is throw when set expectations are not met (see <see cref="T:TypeMock.Mock"/>).
            <para>
            For example when parameters passed are not the ones we expect. When a method is not called or is called
            too often (in Strict mode)
            </para>
            </summary>
        </member>
        <member name="M:TypeMock.VerifyException.#ctor">
            <summary>
            VerifyException is throw when a Mocked call is not as expected <see cref="T:TypeMock.Mock"/>
            </summary>
        </member>
        <member name="M:TypeMock.VerifyException.#ctor(System.String)">
            <summary>
            VerifyException is throw when a Mocked call is not as expected <see cref="T:TypeMock.Mock"/>
            </summary>
            <param name="message">Reason of exception</param>
        </member>
        <member name="M:TypeMock.VerifyException.#ctor(System.String,System.Exception)">
            <summary>
            VerifyException is throw when a Mocked call is not as expected <see cref="T:TypeMock.Mock"/>
            </summary>
            <param name="message">Reason of exception</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="M:TypeMock.VerifyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            For serialization
            </summary>
            <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:TypeMock.VerifyException.BaseMessage">
            <summary>
            Get only base message
            </summary>
        </member>
        <member name="T:ThreadMessaging.MemoryMappingFailedException">
            <exclude/>
        </member>
        <member name="T:ThreadMessaging.MemoryMappedFileView">
            <exclude/>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedFileView.WriteSerialize(System.Object)">
            <summary>
            Serializes the data and writes it to the file.
            </summary>
            <param name="data">The data to serialize.</param>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedFileView.WriteSerialize(System.Object,System.Int32)">
            <summary>
            Serializes the data and writes it to the file.
            </summary>
            <param name="data">The data to serialize.</param>
            <param name="offset">The position in the file to start.</param>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedFileView.WriteSerialize(System.Object,System.Int32,System.Int32)">
            <summary>
            Serializes the data and writes it to the file.
            </summary>
            <param name="data">The data to serialize.</param>
            <param name="offset">The position in the file to start.</param>
            <param name="length">The buffer size in bytes.</param>
        </member>
        <member name="T:TypeMock.TypeParams">
            <exclude/>
            <summary>
            TypeParams is a utility class to handle generics
            </summary>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.Type[])">
            <summary>
            Internal class to handle constructors
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:TypeMock.TypeParams.GetTypes">
            <summary>
            Get the System.Type from RuntimeTypeHandle array
            </summary>
            <returns>Type[]</returns>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
            <param name="handle15"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
            <param name="handle15"></param>
            <param name="handle16"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
            <param name="handle15"></param>
            <param name="handle16"></param>
            <param name="handle17"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
            <param name="handle15"></param>
            <param name="handle16"></param>
            <param name="handle17"></param>
            <param name="handle18"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
            <param name="handle15"></param>
            <param name="handle16"></param>
            <param name="handle17"></param>
            <param name="handle18"></param>
            <param name="handle19"></param>
        </member>
        <member name="M:TypeMock.TypeParams.#ctor(System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle,System.RuntimeTypeHandle)">
            <summary>
            
            </summary>
            <param name="handle0"></param>
            <param name="handle1"></param>
            <param name="handle2"></param>
            <param name="handle3"></param>
            <param name="handle4"></param>
            <param name="handle5"></param>
            <param name="handle6"></param>
            <param name="handle7"></param>
            <param name="handle8"></param>
            <param name="handle9"></param>
            <param name="handle10"></param>
            <param name="handle11"></param>
            <param name="handle12"></param>
            <param name="handle13"></param>
            <param name="handle14"></param>
            <param name="handle15"></param>
            <param name="handle16"></param>
            <param name="handle17"></param>
            <param name="handle18"></param>
            <param name="handle19"></param>
            <param name="handle20"></param>
        </member>
        <member name="M:TypeMock.TypeParams.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TypeMock.TypeParams.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:TypeMock.IMockBehavior">
            <summary>
            Typemock Natural Mocks can validates parameter values, collections and arrays,
            as well as repeat expectation.
            </summary>
            <remarks>
            To change to mock Behavior use IMockBehavior returned from <see cref="T:TypeMock.RecordExpectations"/> methods
            You can validate that parameters passed are as you expected and repeat the expectations.
            <note>
            This Interface is not to be implemented by client 
            </note>
            </remarks>
        </member>
        <member name="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])">
            <summary>
            Validate that the arguments passed are as expected 
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="args">list of expected parameters and/or parameter checkers</param>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if more then 30 parameters are used per method</exception>
            It is possible to check that a mocked method has been called with specific parameter
            values.
            <remarks>
            <para>
            <example>
            For example, if we need to check that an <c>int</c> parameter is 10
            we can write the following code
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // Mock new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // First time PassInt to be called.
                   mockedTestedClass.PassInt(10);
                   // check that 10 has been passed
                   recorder.CheckArguments();
                   
                   // Second time PassInt to be called.
                   mockedTestedClass.PassInt(10);
                   // check that 1 or 2 is passed
                   recorder.CheckArguments(Check.IsIn(1,2)));
                }
                
                // run our code
            	TestedClass t = new TestedClass();
            	// This will pass 
            	t.passInt(10);
            	// This will fail 
            	t.passInt(3);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' Mock new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' First time PassInt to be called.
                   mockedTestedClass.PassInt(10)
                   ' check that 10 has been passed
                   recorder.CheckArguments()
                   
                   ' Second time PassInt to be called.
                   mockedTestedClass.PassInt(10);
                   ' check that 1 or 2 is passed
                   recorder.CheckArguments(Check.IsIn(1,2)))
                End Using
            
                '  run our code
            	Dim t As TestedClass = New TestedClass
            	' This will pass 
            	t.passInt(10)
            	' This will fail 
            	t.passInt(3)
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            Single Dimension Arrays and Collections are iterated and checked for match of all items
            See <see cref="T:TypeMock.Check"/> for built in ParameterCheckers 
            See <see cref="T:TypeMock.ParameterChecker"/> for details of user defined checks 
            
            <note>
            BEWARE, Typemock Isolator normally checks the type of return value with the existing
            method, but it does not check the legitimacy of the returned value in case of
            overloaded methods that have different return types, (as Typemock Isolator sees these 
            as one mocked method) if you return a value with the wrong type a 
            <c>System.InvalidCastException</c> will be thrown
            </note>
            <note>
            Typemock Isolator supports checking methods with up to 30 parameters 
            </note>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </remarks>
        </member>
        <member name="M:TypeMock.IMockBehavior.WhenArgumentsMatch(System.Object[])">
            <summary>
            Mock method only when arguments passed are as expected 
            <seealso cref="T:TypeMock.ParameterChecker"/>
            <seealso cref="T:TypeMock.Check"/>
            </summary>
            <param name="args">list of expected parameters and/or parameter checkers</param>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if more then 30 parameters are used per method</exception>
            It is possible to check that a mocked method has been called with specific parameter
            values and to return mocked values when this is true.
             *Enterprise Edition Only*
            <remarks>
            <para>
            <example>
            For example, we have a method PassInt, that returns a <c>string</c>, and has an <c>int</c> parameter.
            We need to return "one" whenever the argument is 1
            we can write the following code
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // Mock new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // always return "one" when 1 was passed
                   mockedTestedClass.PassInt(1);
                   recorder.Return("one").RepeatAlways().WhenArgumentsMatch();
            
                   // always return "two" when 2 or 3 is passed
                   mockedTestedClass.PassInt(2);
                   recorder.Return("two").RepeatAlways().WhenArgumentsMatch(Check.IsIn(1,2));
                }
                
                // run our code
            	TestedClass t = new TestedClass();
            	// This will pass 
                Assert.AreEqual("one",t.passInt(1));
                Assert.AreEqual("two",t.passInt(3));
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' Mock new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' always return "one" when 1 was passed
                   mockedTestedClass.PassInt(1)
                   recorder.Return("one").RepeatAlways().WhenArgumentsMatch()
                   
                   '  always return "two" when 2 or 3 is passed
                   mockedTestedClass.PassInt(2);
                   recorder.Return("two").RepeatAlways().WhenArgumentsMatch(Check.IsIn(1,2))
                End Using
            
                '  run our code
            	Dim t As TestedClass = New TestedClass
            	' This will pass 
                Assert.AreEqual("one",t.passInt(1))
                Assert.AreEqual("two",t.passInt(3))
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            Single Dimension Arrays and Collections are iterated and checked for match of all items
            See <see cref="T:TypeMock.Check"/> for built in ParameterCheckers 
            See <see cref="T:TypeMock.ParameterChecker"/> for details of user defined checks 
            
            <note>
            BEWARE, Typemock Isolator normally checks the type of return value with the existing
            method, but it does not check the legitimacy of the returned value in case of
            overloaded methods that have different return types, (as Typemock Isolator sees these 
            as one mocked method) if you return a value with the wrong type a 
            <c>System.InvalidCastException</c> will be thrown
            </note>
            <note>
            Typemock Isolator supports checking methods with up to 30 parameters 
            </note>
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.ParameterChecker"/>
            </remarks>
        </member>
        <member name="M:TypeMock.IMockBehavior.IgnoreArguments">
            <summary>
            Don't Validate that the arguments passed are as expected. This is the default Behavior
            <seealso cref="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])"/>
            </summary>
            <remarks>
            <para>
            <example>
            For example, if we want to ignore the parameters passed we can write the following code
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // Mock new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // First time PassInt to be called.
                   mockedTestedClass.PassInt(10);
                   // don't check that 10 has been passed
                   recorder.IgnoreArguments();
                   
                   // Second time PassInt to be called.
                   mockedTestedClass.PassInt(10);
                   // check that 1 or 2 is passed
                   recorder.CheckArguments(Check.IsIn(1,2)));
                }
                
                // run our code
            	TestedClass t = new TestedClass();
            	// This will pass (ignored)
            	t.passInt(1);
            	// This will fail 
            	t.passInt(3);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations]
                   ' CAUTION: ALL calls here are mocked!!!
                   ' Mock new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' First time PassInt to be called.
                   mockedTestedClass.PassInt(10)
                   ' don't check that 10 has been passed
                   recorder.IgnoreArguments()
                   
                   ' Second time PassInt to be called.
                   mockedTestedClass.PassInt(10);
                   ' check that 1 or 2 is passed
                   recorder.CheckArguments(Check.IsIn(1,2)))
                End Using
            
                '  run our code
            	Dim t As TestedClass = New TestedClass
            	' This will pass (ignored)
            	t.passInt(1)
            	' This will fail 
            	t.passInt(3)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.IMockBehavior.Repeat(System.Int32)">
            <summary>
            Repeat the last expectation and mocked return values
            </summary>
            <remarks>
            <para>
            <example>
            For example, lets repeat the expectation for DoSomething 3 times
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // Mock new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be called.
                   mockedTestedClass.DoSomething();
                   // return 10, 3 times
                   recorder.Return(10).Repeat(3);
                }
                
                // run our code
             TestedClass t = new TestedClass();
                int actual = t.DoSomething();
             Assert.AreEqual(10,actual);
                int actual = t.DoSomething();
             Assert.AreEqual(10,actual);
             // This will fail as we have one more expectation 
             MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' Mock new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be called.
                   mockedTestedClass.DoSomething()
                   ' return 10, 3 times
                   recorder.Return(10).Repeat(3)
                End Using
            
                '  run our code
             Dim t As TestedClass = New TestedClass
                Dim actual As Integer = t.DoSomething()
            	 Assert.AreEqual(10,actual);
                actual = t.DoSomething()
            	 Assert.AreEqual(10,actual);
             ' This will fail as we have one more expectation 
             MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            <note>When using Chained expectations the repeat will repeat ALL the calls in the chain</note>
            </remarks>
            <param name="timesToRun">Amount of times to repeat the expectation</param>
            <returns>Use to change more Behavior</returns>
        </member>
        <member name="M:TypeMock.IMockBehavior.RepeatAlways">
            <summary>
            Repeat the last expectation and mocked return values for every call
            </summary>
            <remarks>
            <para>
            <example>
            For example, lets repeat the expectation for DoSomething 
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // Mock new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be called.
                   mockedTestedClass.DoSomething();
                   // always return 10
                   recorder.Return(10).RepeatAlways();
                }
                
                // run our code
                TestedClass t = new TestedClass();
                int actual = t.DoSomething();
                Assert.AreEqual(10,actual);
                int actual = t.DoSomething();
                Assert.AreEqual(10,actual);
                MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' Mock new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be called.
                   mockedTestedClass.DoSomething()
                   ' always return 10
                   recorder.Return(10).RepeatAlways()
                End Using
            
                '  run our code
                Dim t As TestedClass = New TestedClass
                Dim actual As Integer = t.DoSomething()
                Assert.AreEqual(10,actual);
                actual = t.DoSomething()
            	Assert.AreEqual(10,actual);
                MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            <note>When using Chained expectations the repeat will repeat ALL the calls in the chain</note>
            </remarks>
            <returns>Use to change more Behavior</returns>
        </member>
        <member name="T:ThreadMessaging.IChannel">
            <exclude/>
            <summary>
            A channel is a queued but blocking message channel.
            Channels are useful for Inter-Thread or Inter-Process communication, depending on the implementation.
            Usually all interfaces members of this type are thread-safe.
            </summary>
        </member>
        <member name="T:ThreadMessaging.IReliability">
            <exclude/>
            <summary>
            The reliability interface provides automatic (in case of a thread interrup as happens on see cref="IRunnable.Stop()") and manual dumping.
            </summary>
        </member>
        <member name="M:ThreadMessaging.IReliability.Dump">
            <summary>Copy all data hold by the structure to the local dump container and clears the structure.</summary>
            <remarks>A structure is invalid and no longer usable after dumping. You should notify all the other threads/processes before dumping.</remarks>
        </member>
        <member name="P:ThreadMessaging.IReliability.IsDumped">
            <summary>True if there's any data in the dump container.</summary>
        </member>
        <member name="P:ThreadMessaging.IReliability.DumpContainer">
            <summary>The dump container data structure</summary>
        </member>
        <member name="M:ThreadMessaging.IChannel.Send(System.Object)">
            <summary>Send a message to the channel with unlimited timeout.</summary>
            <param name="item">The object to send. There may be limitations on the kind of objects allowed - e.g. to be masked with the SerializedAttribute.</param>
        </member>
        <member name="M:ThreadMessaging.IChannel.Send(System.Object,System.TimeSpan)">
            <summary>Send a message to the channel with limited timeout.</summary>
            <param name="item">The object to send. There may be limitations on the kind of objects allowed - e.g. to be masked with the SerializedAttribute.</param>
            <param name="timeout">The maximum blocking time. Usually an Exceptions is thrown if a timeout exceeds.</param>
        </member>
        <member name="M:ThreadMessaging.IChannel.Receive">
            <summary>Receive a message from the channel with unlimited timeout.</summary>
            <returns>The received object.</returns>
        </member>
        <member name="M:ThreadMessaging.IChannel.Receive(System.TimeSpan)">
            <summary>Receive a message from the channel with limited timeout.</summary>
            <param name="timeout">The maximum blocking time. Usually an Exceptions is thrown if a timeout exceeds.</param>
            <returns>The received object.</returns>
        </member>
        <member name="T:TypeMock.UpgradeReminderForm">
            <summary>
            Summary description for About.
            </summary>
        </member>
        <member name="M:TypeMock.UpgradeReminderForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:TypeMock.UpgradeReminderForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.Clear">
            <summary>
            clear all expectations from table.
            </summary>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.Contains(System.Type)">
            <summary>
            Find if type has expectations.
            </summary>
            <param name="type">The type to look for</param>
            <returns>true if type has expectations, false otherwise</returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.GetKeyForAbstractMethod(System.String,System.Type)">
            <summary>
            If type is abstract insert "Mock" at the start of type name. 
            </summary>
            <param name="key"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.Find(System.Type)">
            <summary>
            Returns the Expectation for the given type.
            </summary>
            <param name="type">The type</param>
            <returns>The expectation for the type</returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.Find(System.String,System.Object)">
            <summary>
            Returns the Expectation for the given type.
            </summary>
            <param name="typeName">the name of the type to look for</param>
            <returns></returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.CreateExpectation(System.Type)">
            <summary>
            Create expectations for the given type
            </summary>
            <param name="type">The type</param>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.GetAllMockedTypes">
            <summary>
            returns all types that has expectations.
            </summary>
            <returns>type array containing list of types that has expectations.</returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.VerifyExpectations">
            <summary>
            Verify that all expectations in table has been met
            </summary>
            <returns>String describing the verify problem, an empty string if all expectations has been met</returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.VerifyExpectationsWithTimeout(System.Int32)">
            <summary>
            Verify that all expectations in table has been met
            </summary>
            <param name="msec">the timeout in Millisecond</param>
            <returns>String describing the verify problem, an empty string if all expectations has been met</returns>
        </member>
        <member name="M:TypeMock.TypeExpectationMap.HasExpectations(System.Type)">
            <summary>
            checks if type has any expectations on it (used to decide if cctor should be invoked)
            </summary>
            <param name="type">the type to check</param>
            <returns>true if user set an explicit expecation on any of the methods</returns>
        </member>
        <member name="T:TypeMock.DynamicReturnValue">
            <summary>
            Delegate to implement a custom return value
            </summary>
            <remarks>
            Typemock Isolator allows you to specify mocked return values for mocked methods.
            These values are normally hard coded, but
            there are some cases where this is not enough and a custom return value is needed,
            to do so create a delegation method and pass it as the return value to 
            one of the <see cref="T:TypeMock.Mock"/> setup methods 
            <para>
            <example>
            For example, if we need to return the first <c>int</c> parameter of a mocked method, but throw an exception
            if the value is 0, we can write the following code 
            <code lang="cs">
            public static object MyReturnValue(object[] parameters, object context) 
            {
            	if ((int)parameters[0]==0) 
            	{
            		throw new Exception();
            	}
            	return parameters[0];
            }
            </code>
            <code lang="vbnet">
            Public Shared Function MyReturnValue(ByVal parameters() As Object, ByVal that As Object) As Object
            	If parameters(0)=0 Then
                   Throw New Exception
            	End If
            	MyReturnValue = parameters(0)
            End Function
            </code>
            We can then use it in our test
            <code lang="cs">
            [Test]
            public void Test() 
            {
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	// getInt will be called, it will return our dynamic values
            	mock.AlwaysReturn("getInt",new DynamicReturnValue(MyReturnValue));
            	TestedClass t = new TestedClass();
            	// This will pass
            	Assert.AreEqual(10,t.getVar(10));
            	// so will this
            	Assert.AreEqual(1,t.getVar(1));
            	// this will throw an exception
            	t.getVar(0);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test() 
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	' getInt will be called, it will return our dynamic values
            	mock.AlwaysReturn("getInt",New DynamicReturnValue(AddressOf MyReturnValue))
            	Dim t As TestedClass = New TestedClass()
            	' This will pass
            	Assert.AreEqual(10,t.getVar(10))
            	' so will this
            	Assert.AreEqual(1,t.getVar(1))
            	' this will throw an exception
            	t.getVar(0)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </para>
            <note>
            BEWARE, Typemock Isolator does not check the legitimacy of the returned value, if you 
            return a value with the wrong type a <c>System.InvalidCastException</c> will be 
            thrown
            </note>
            <note>
            BEWARE, All code that is run inside the delegate is NOT mocked. 
            thrown
            </note>
            <note>
            To continue with the original method without mocking, return <see cref="P:TypeMock.MockManager.CONTINUE_WITH_METHOD"/>
            </note>
            <note>
            You can use <c>DynamicReturnValue</c> to change <c>ref</c> and <c>out</c> parameters
            Just change the values of the parameters array and if the parameter is referenced it will change its
            value. Again Typemock Isolator does not check the legitimacy of the value.
            </note>
            </remarks>
            <param name="parameters">array of parameters passed to mocked method</param>
            <param name="context">a reference to the mocked object instance, or null if the method is static</param>
            <returns>custom return value</returns>
            <exception cref="T:System.InvalidCastException">If return a value of the wrong type</exception>
        </member>
        <member name="T:TypeMock.MockMethodCalledEventHandler">
            <summary>
            Event that is fired after a mocked method is called and after validation is performed
            </summary>
            <param name="sender">The Mocked Object or null is the method called is static</param>
            <param name="e">Event Method</param>
            <remarks>
            The following example will setup Typemock Isolator to call SuccessEvent after each call to a mocked
            method.
            <example>
            <code lang="cs">
            // This will be called when a mocked method is called
            private void SuccessEvent(object sender,MockMethodCallEventArgs e) 
            {
            	Assert.AreEqual(typeof(TestedClass),e.CalledType);
            	Assert.AreEqual("getVar",e.CalledMethodName);
            	Assert.AreEqual(0,e.SentArguments.Length);
            	Assert.AreEqual(0,e.ExpectedArguments.Length);
            	Assert.AreEqual(false,e.WillThrowException);
            	Assert.AreEqual(null,e.Exception);
            	Assert.AreEqual(5,e.ReturnValue);
            	Assert.AreEqual(true,e.HasPassedValidation);
            }
            [Test]
            public void SimpleEventSuccess() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass),false);
            	TestedClass t = new TestedClass();
            	
            	mock.ExpectAndReturn("getVar",5);
            	// set event listener
            	mock.MockMethodCalled += new MockMethodCalledEventHandler(SuccessEvent);
            	// the event will be called
            	Assert.AreEqual(5,t.getVar());
            	mock.Verify();
            }
            </code>
            
            <code lang="vbnet">
            ' This will be called when a mocked method is called
            Public Shared Sub SuccessEvent(ByVal sender As Object, ByVal e As MockMethodCallEventArgs) 
            	Assert.AreEqual(GetType(TestedClass),e.CalledType)
            	Assert.AreEqual("getVar",e.CalledMethodName)
            	Assert.AreEqual(0,e.SentArguments.Length)
            	Assert.AreEqual(0,e.ExpectedArguments.Length)
            	Assert.AreEqual(False,e.WillThrowException)
            	Assert.AreEqual(Nothing,e.Exception)
            	Assert.AreEqual(5,e.ReturnValue)
            	Assert.AreEqual(True,e.HasPassedValidation)
            End Sub
            
            &lt;Test()&gt; _
            Public Sub SimpleEventSuccess()
            	Dim t As TestedClass = new TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	
            	mock.ExpectAndReturn("getVar",5)
            	' set event listener
                AddHandler mock.MockMethodCalled, AddressOf SuccessEvent
            	' the event will be called
            	Assert.AreEqual(5,t.getVar())
            	mock.Verify()
            End Sub
            </code>
            </example>
            To set an event per method see <see cref="T:TypeMock.IMethodSettings"/> and Mock.<see cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            To set a global event for a mocked type see Mock.<see cref="E:TypeMock.Mock.MockMethodCalled"/>
            <note>When static methods are called events from ALL mocks of that type are triggered. So if a type is mocked for
            two instances, and both have AfterMock Events, both will be triggered after a static member of that type is called. This 
            is because static methods are not associated with an instance.</note>
            <seealso cref="E:TypeMock.Mock.MockMethodCalled"/>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <seealso cref="T:TypeMock.IMethodSettings"/>
            </remarks>
        </member>
        <member name="T:TypeMock.VerifyMode">
            <summary>
            Verify Mode is the way that Typemock Isolator verifies uncalled expected methods
            <seealso cref="M:TypeMock.Mock.StartBlock"/>
            <seealso cref="P:TypeMock.Mock.Strict"/>
            </summary>
        </member>
        <member name="F:TypeMock.VerifyMode.Normal">
            <summary>
            Fail if an expected method is not called
            </summary>
        </member>
        <member name="F:TypeMock.VerifyMode.PassIfNotCalled">
            <summary>
            Pass even if an expected method is not called
            </summary>
        </member>
        <member name="F:TypeMock.VerifyMode.DontClear">
            <summary>
            Expectations will not fail if some calls are still expected and expectations are not cleared.
            To Clear use <see cref="M:TypeMock.Mock.Clear"/> or <see cref="M:TypeMock.MockManager.Init"/>
            </summary>
        </member>
        <member name="T:TypeMock.TypeMockException">
            <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager"/>
            <example>
            For example when trying to return an incorrect type
            </example>
            </summary>
        </member>
        <member name="M:TypeMock.TypeMockException.#ctor(System.String)">
            <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager"/>
            </summary>
            <param name="message">Reason of exception</param>
        </member>
        <member name="M:TypeMock.TypeMockException.#ctor">
            <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager"/>
            </summary>
        </member>
        <member name="M:TypeMock.TypeMockException.#ctor(System.String,System.Exception)">
            <summary>
            TypeMockException is throw when illegal arguments are received by <see cref="T:TypeMock.MockManager"/>
            </summary>
            <param name="message">Reason of exception</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="M:TypeMock.TypeMockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the TypeMockException class with serialized data.
            </summary>
            <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:TypeMock.CannotEvaluateWhileRecordingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the CannotEvaluateWhileRecordingException class with serialized data.
            </summary>
            <param name="info">The SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:TypeMock.AddinConnection.AddInListener.CheckMutexIfInBreakMode">
            <summary>
            Checks if we are in Break Mode according to the Mutex.
            If we are, result is true, and we need to release the lock.
            </summary>
            <returns></returns>
        </member>
        <member name="P:TypeMock.AddinConnection.AddInListener.DebuggingMode">
            <summary>
            In Run mode, functions need to be run, thus setting expectations in Typemock Isolator
            But in Break mode, we don't want to evaluate functions that will set the expecation, 
            and this way we can block them. 
            If we are in Break mode, we know this by acquiring the mutex, and so we need to release it
            </summary>
        </member>
        <member name="T:TypeMock.State">
            <summary>
            Saves state of object
            </summary>
        </member>
        <member name="T:TypeMock.ObjectState">
             <summary>
             Utility Class that takes a snapshot of all the fields of an object or the static fields of a type
             , in order to reset all the fields back to the saved state.
             </summary>
             <remarks>
             The ObjectState assists testing classes with hidden field, by resetting these field
             when required
             <example>
             The following example we want to test a class that has a static counter.
             <code lang="cs">
             public class StatefulClass
             {
             	static private int count = 0;
             	public int Count {get { return count++ ;}}
             }
            
             [Test]
             public void Stateful()
             {
             	StatefulClass stateful = new StatefulClass();
             	// Save our state
                 ObjectState objState = new ObjectState(state);
                 // Do something to change the state
            		Assert.AreEqual(0,stateful.Count);
            		// lets reset our code for next test
            		objState.ResetState();
            		Assert.AreEqual(0,stateful.Count);
            	}
             </code>
             <code lang="vbnet">
             Public Class StatefulClass
             	Private Shared count As Integer = 0
                 Public ReadOnly Property Count() As Integer
                 	Get
                 		Return _defaultName
                 	End Get
                 End Property
              End Class
            
             &lt;Test()&gt; _
             Public Sub Stateful()
             	Dim stateful As StatefulClass = New StatefulClass
             	' Save our state
                 Dim objState As ObjectState = New ObjectState(state)
                 ' Do something to change the state
            		Assert.AreEqual(0,stateful.Count)
            		' lets reset our code for next test
            		objState.ResetState()
            		Assert.AreEqual(0,stateful.Count)
            	End Sub
             </code>
             </example>
             </remarks>
        </member>
        <member name="M:TypeMock.ObjectState.#ctor(System.Object)">
            <summary>
            Take a snapshot of <b>all</b> the fields of an object, in order to reset
            all the fields back to the saved state.
            </summary>
            <param name="obj">The object to save the state</param>
        </member>
        <member name="M:TypeMock.ObjectState.#ctor(System.Type)">
            <summary>
            Take a snapshot of all the <b>static</b> fields of a type, in order to reset
            all the fields back to the saved state.
            </summary>
            <param name="type">The type to save the state</param>
        </member>
        <member name="M:TypeMock.ObjectState.ResetState">
            <summary>
            Reset the fields back to their original state
            </summary>
        </member>
        <member name="M:TypeMock.ObjectState.SetField(System.String,System.Object)">
            <summary>
            Sets the value of a non-public field (member variable) of the managed type.
            </summary>
            <param name="fieldName">The name of the non-public field to modify.</param>
            <param name="value">value whose type is specific to the field.</param>
        </member>
        <member name="M:TypeMock.ObjectState.SetField(System.Object,System.String,System.Object)">
            <summary>
            Sets the value of a non-public field (member variable) of an instance.
            </summary>
            <param name="obj">The instance to modify</param>
            <param name="fieldName">The name of the non-public field to modify.</param>
            <param name="value">value whose type is specific to the field.</param>
        </member>
        <member name="M:TypeMock.ObjectState.SetField(System.Type,System.String,System.Object)">
            <summary>
            Sets the value of a non-public static field (member variable) of a type.
            </summary>
            <param name="type">The type to modify</param>
            <param name="fieldName">The name of the non-public static field to modify.</param>
            <param name="value">value whose type is specific to the field.</param>
        </member>
        <member name="M:TypeMock.ObjectState.GetField(System.String)">
            <summary>
            Gets the value of a non-public field (member variable) of the managed type.
            </summary>
            <param name="fieldName">The name of the non-public field to modify.</param>
            <returns>value whose type is specific to the field.</returns>
        </member>
        <member name="M:TypeMock.ObjectState.GetField(System.Object,System.String)">
            <summary>
            Gets the value of a non-public field (member variable) of an instance.
            </summary>
            <param name="obj">The instance to read</param>
            <param name="fieldName">The name of the non-public field to modify.</param>
            <returns>value whose type is specific to the field.</returns>
        </member>
        <member name="M:TypeMock.ObjectState.GetField(System.Type,System.String)">
            <summary>
            Gets the value of a non-public static field (member variable) of a type.
            </summary>
            <param name="type">The type to read</param>
            <param name="fieldName">The name of the non-public static field to modify.</param>
            <returns>value whose type is specific to the field.</returns>
        </member>
        <member name="T:TypeMock.Tracer">
            <exclude/>
            <summary>
            Connect to Tracer. These API's might change do not use.
            </summary>
        </member>
        <member name="M:TypeMock.Tracer.#ctor">
            <summary>
            Internal Tracer Class that communicates with the Tracer GUI.
            </summary>
        </member>
        <member name="P:TypeMock.Tracer.ClientIsRunning">
            <summary>
            Return id Trace client is running - this is used internally and might change without notice
            </summary>
        </member>
        <member name="T:TypeMock.RemoteTracer">
            <exclude/>
            <summary>
            Internal use only.
            Used as a remotable tracer object. The tracer will create this object and we will send
            our data through it.
            </summary>
        </member>
        <member name="M:TypeMock.RemoteTracer.SendData(TypeMock.TraceData)">
            <summary>
            Send data to the server.
            </summary>
            <param name="data"></param>
        </member>
        <member name="E:TypeMock.RemoteTracer.FireTrace">
            <summary>
            This event must be setup to work.
            </summary>
        </member>
        <member name="P:TypeMock.RemoteTracer.IsAlive">
            <summary>
            Has Server Loaded.
            </summary>
        </member>
        <member name="T:TypeMock.RemoteTracer.FireTraceEventHandler">
            <summary>
            Used to hook Tracer (Server)
            </summary>
            <param name="sender"></param>
            <param name="data"></param>
        </member>
        <member name="F:TypeMock.RecordedMocksContainer.m_RecordedMocks">
            <summary>
            Holds all the created mocks
            </summary>
        </member>
        <member name="T:ThreadMessaging.MemoryMappedArrayFailedException">
            <exclude/>
        </member>
        <member name="T:TypeMock.MethodCallCounter">
            <summary>
            CallCounter counts the calls to all registered methods 
            <see cref="P:TypeMock.MockManager.CollectAllCalls"/>
            </summary>
        </member>
        <member name="T:TypeMock.ExpectationBlock">
            <summary>
            An expectation block (Enterprise Edition Only)
            </summary>
            <remarks>
            <para>
            Group a number of expectation. Define an expectation block using Mock.<see cref="M:TypeMock.Mock.StartBlock"/> and Mock.<see cref="M:TypeMock.Mock.EndBlock"/>. 
            When grouping expectations in a block you can control
            The expectation dynamically. This is very useful when setting up a mock infrastructure.
            After defining a block it is possible to:
            <list type="number">
            <item>Remove the block using Mock.<see cref="M:TypeMock.Mock.Clear(TypeMock.ExpectationBlock)"/>.
            </item>
            <item>
            Add expectations before the block using Mock.<see cref="M:TypeMock.Mock.StartBlockBefore(TypeMock.ExpectationBlock)"/>.
            </item>
            </list>
            
            Blocks can be labeled and can be later on referred to by Mock.<see cref="M:TypeMock.Mock.GetBlock(System.String)"/>.
            
            Blocks can have different <see cref="T:TypeMock.VerifyMode"/>s.
            <example>
            The following example shows a utility method that sets up expectations 
            for an AccessController
            <code lang="cs">
            private Mock SetupExpectations()
            {
            	//Mock all invocation of AccessController, 
            	Mock mock = MockManager.MockAll(typeof(AccessController));
            
            	// start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal);
            	 // We expect that the login method will be called and we will return 
            	 // AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 // second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	return mock;
            }
            [Test]
            public void TestSomething()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"));
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED);
            	mock.EndBlock();
            	
            	// continue with test
            }
            [Test]
            public void TestSomething2()
            {
            	Mock mock = SetupExpectations();
            	
            	// In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"));
            	
            	// continue with test
            }
            </code>
            <code lang="vbnet">
            Private Function SetupExpectations() As Mock 
            	'Mock all invocation of AccessController, 
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' start a block called loginLabel, this will be verified normally
            	mock.StartBlock("loginLabel",VerifyMode.Normal)
            	 ' We expect that the login method will be called and we will return 
            	 ' AccessStatus.INVALID_USER the first time and AccessStatus.VALIDATED the 
            	 ' second time
            	 mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            	 mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' expect another call and return validated.
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	SetupExpectations = mock
            End Function
            &lt;Test()&gt; _
            Public Sub TestSomething()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to add an expectation before our block
            	mock.StartBlockBefore(mock.GetBlock("loginLabel"))
            	mock.ExpectAndReturn("Login", AccessStatus.VALIDATED)
            	mock.EndBlock()
            	
            	' continue with test
            End Sub
            &lt;Test()&gt; _
            Public Sub TestSomething2()
            	Dim mock As Mock = SetupExpectations()
            	
            	' In this test we need to remove the expectation our block
            	mock.Clear(mock.GetBlock("loginLabel"))
            	
            	' continue with test
            End Sub
            </code>
            </example>
            <seealso cref="T:TypeMock.VerifyMode"/>
            <seealso cref="M:TypeMock.Mock.GetBlock(System.String)"/>
            <seealso cref="M:TypeMock.Mock.Clear(System.String)"/>
            </para>
            </remarks>
            <returns>The Expectation Block</returns>	
        </member>
        <member name="F:TypeMock.ExpectationBlock.FIRST_FREE_ID">
            <summary>
            first two ids are reserved for firstBlock and lastBlock.
            </summary>
        </member>
        <member name="P:TypeMock.ExpectationBlock.Name">
            <summary>
            Return the default expectation block
            </summary>
            <summary>
            The Name or Label of the Block
            </summary>
        </member>
        <member name="T:TypeMock.CallCounterTable">
            <summary>
            This class will holds all the calls counters for all the types.
            FIXME Lior - this class is uses strings in order to match method signatures, need to consider working with real
            signatures.
            </summary>
        </member>
        <member name="F:TypeMock.CallCounterTable.m_CountersMap">
            <summary>
            The counter tables: hash from type,MethodName,methodParams->counter
            </summary>
        </member>
        <member name="M:TypeMock.CallCounterTable.#ctor">
            <summary>
            default ctor
            </summary>
        </member>
        <member name="M:TypeMock.CallCounterTable.CalledCounter(System.String,System.String,TypeMock.TypeParams)">
            <summary>
            retrieve the counter of the given method.
            </summary>
            <param name="type">the name of the class.</param>
            <param name="methodName">the name of the method</param>
            <param name="methodParams">if the method is generic needs generic types</param>
            <returns>the number of times the method got called. 0 if not found</returns>
        </member>
        <member name="M:TypeMock.CallCounterTable.CalledCounter(System.Type,System.String,TypeMock.TypeParams)">
            <summary>
            retrieve the number of times the given method has been called.
            </summary>
            <param name="type">the type of the class.</param>
            <param name="methodName">the name of the method</param>
            <param name="methodParams">if the method is generic needs generic types</param>
            <returns>the number of times the method has been called, 0 if method not found.</returns>
        </member>
        <member name="M:TypeMock.CallCounterTable.AddCall(System.String,System.String,TypeMock.TypeParams)">
            <summary>
            Increase the counter of the given method
            </summary>
            <param name="type">the name of the class.</param>
            <param name="methodName">the name of the method</param>
            <param name="methodParams">if the method is generic needs generic types</param>
        </member>
        <member name="M:TypeMock.CallCounterTable.Clear">
            <summary>
            clear all stored counters
            </summary>
        </member>
        <member name="T:ThreadMessaging.ProcessChannel">
            <exclude/>
            <summary>
            ProcessChannel is a queued Inter-Process message channel.
            Only objects masked with the <see cref="T:System.SerializableAttribute"/> are allowed to be transfered through this channel.
            </summary>
            <remarks>All members of this class are thread-safe.</remarks>
        </member>
        <member name="T:ThreadMessaging.ProcessReliability">
            <exclude/>
        </member>
        <member name="M:ThreadMessaging.ProcessReliability.DumpStructure">
            <summary>
            </summary>
        </member>
        <member name="M:ThreadMessaging.ProcessReliability.DumpItemSynchronized(System.Object)">
            <summary>
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:ThreadMessaging.ProcessReliability.DumpItem(System.Object)">
            <summary>
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:ThreadMessaging.ProcessReliability.Dump">
            <summary>
            Copy all data hold by the structure to the local dump container and clears the structure.
            </summary>
            <remarks>A structure is invalid and no longer usable after dumping. You should notify all the other threads/processes before dumping.</remarks>
        </member>
        <member name="P:ThreadMessaging.ProcessReliability.DumpSyncRoot">
            <summary>
            </summary>
        </member>
        <member name="P:ThreadMessaging.ProcessReliability.IsDumped">
            <summary>
            True if there's any data in the dump container.
            </summary>
        </member>
        <member name="P:ThreadMessaging.ProcessReliability.DumpContainer">
            <summary>
            The dump container data structure
            </summary>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.#ctor(System.Int32,System.String,System.Int32)">
            <summary>
            Instanciates an Inter-Process message channel.
            </summary>
            <param name="size">The count of messages the channel can queue before it blocks.</param>
            <param name="name">The channel's name. Must be the same for all instances using this channel.</param>
            <param name="maxBytesPerEntry">The maximum serialized message size in terms of bytes. Must be the same for all instances using this channel.</param>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.Send(System.Object)">
            <summary>
            Send a message to the channel with unlimited timeout.
            </summary>
            <param name="item">The object to send. Only objects masked with the <see cref="T:System.SerializableAttribute"/> are allowed to be transfered through this channel.</param>
            <remarks>This member is thread-safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.Send(System.Object,System.TimeSpan)">
            <summary>
            Send a message to the channel with unlimited timeout.
            </summary>
            <param name="item">The object to send. Only objects masked with the <see cref="T:System.SerializableAttribute"/> are allowed to be transfered through this channel.</param>
            <param name="timeout">The maximum blocking time. A SemaphorFailedException is thrown if a timout exceeds.</param>
            <remarks>This member is thread-safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.Receive">
            <summary>
            Receive a message from the channel with unlimited timeout.
            </summary>
            <returns>The received object.</returns>
            <remarks>This member is thread safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.Receive(System.TimeSpan)">
            <summary>
            Receive a message from the channel with limited timeout.
            </summary>
            <param name="timeout">The maximum blocking time. A SemaphorFailedException is thrown if a timout exceeds.</param>
            <returns>The received object.</returns>
            <remarks>This member is thread safe.</remarks>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.DumpStructure">
            <summary>
            
            </summary>
        </member>
        <member name="M:ThreadMessaging.ProcessChannel.Dispose">
            <summary>
            Don't forget to dispose this object before destruction.
            </summary>
        </member>
        <member name="M:TypeMock.MethodBehaviorRepository.Clear(TypeMock.Mock)">
            <summary>
            Clear all expectations of a mock (clears static members made by an instance mock)
            </summary>
            <returns>if no expectations are left</returns>
        </member>
        <member name="P:TypeMock.MethodBehaviorRepository.HasConditionalExpectationsLeft">
            <summary>
            this return true if we have unfulfiled conditional returns
            </summary>
        </member>
        <member name="T:TypeMock.VerifyMessageBuilder">
            <summary>
            Helper for building failure messages
            </summary>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.#ctor(System.String,System.Object[])">
            <summary>
            Create a Message Builder
            </summary>
            <param name="message">Custom message</param>
            <param name="args">Arguments for custom message</param>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.AddToPrefix(System.String)">
            <summary>
            Add message to prefix, remember current prefix
            </summary>
            <param name="prefix">Message to add</param>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.RemoveLastPrefix">
            <summary>
            Restore prefix to last known
            </summary>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.SetMessage(TypeMock.ParameterCheckerEventArgs,System.String)">
            <summary>
            Set message with one text
            </summary>
            <param name="data">Information about the checked argument</param>
            <param name="message">Error Message</param>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.SetMessage(TypeMock.ParameterCheckerEventArgs,System.Object,System.Object)">
            <summary>
            Set message with expected and actual objects
            </summary>
            <param name="data">Information about the checked argument</param>
            <param name="expected">The expected argument</param>
            <param name="actual">The actual argument</param>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.SetMessage(TypeMock.ParameterCheckerEventArgs,System.String,System.Object,System.Object)">
            <summary>
            Set message with prefix string and expected and actual objects
            </summary>
            <param name="data">Information about the checked argument</param>
            <param name="prefix">Prefix to add to message</param>
            <param name="expected">The expected argument</param>
            <param name="actual">The actual argument</param>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.ToString">
            <summary>
            Get Message string
            </summary>
            <returns>The message string</returns>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.BuildCallString(TypeMock.ParameterCheckerEventArgs)">
            <summary>
            Default message prefix that can be added to the message
            </summary>
            <remarks>
            The message is: Call to [namespace.method] Parameter: [number] 
            </remarks>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.DisplayString(System.Object)">
            <summary>
            Display an object as a string
            </summary>
            <param name="obj">The object to display</param>
            <returns>String representation of object</returns>
        </member>
        <member name="M:TypeMock.VerifyMessageBuilder.Quoted(System.String)">
            <summary>
            Quote a string
            </summary>
            <param name="text">Text to Quote</param>
            <returns>Quoted string</returns>
        </member>
        <member name="P:TypeMock.VerifyMessageBuilder.CustomMessage">
            <summary>
            Set/Get the CustomMessage
            </summary>
        </member>
        <member name="P:TypeMock.VerifyMessageBuilder.PrefixMessage">
            <summary>
            Set/Get Prefix to add before message
            </summary>
        </member>
        <member name="P:TypeMock.VerifyMessageBuilder.Message">
            <summary>
            Get Message String
            </summary>
        </member>
        <member name="T:TypeMock.Scope">
            <exclude/>
            <summary>
            Scope of Mock 
            </summary>
        </member>
        <member name="F:TypeMock.Scope.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="F:TypeMock.Scope.Static">
            <summary>
            
            </summary>
        </member>
        <member name="F:TypeMock.Scope.All">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceData">
            <exclude/>
            <summary>
            Summary description for TraceData.
            </summary>
        </member>
        <member name="M:TypeMock.TraceData.#ctor">
            <summary>
            Base Trace Object
            </summary>
        </member>
        <member name="M:TypeMock.TraceData.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceData.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TypeMock.TraceDataInit">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataInit.#ctor(System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="M:TypeMock.TraceDataInit.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataInit.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataInit.SessionNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:TypeMock.TraceDataInit.Info">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataTestName">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataTestName.#ctor(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:TypeMock.TraceDataTestName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataTestName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataTestName.TestName">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataHidden">
            <exclude/>
        </member>
        <member name="T:TypeMock.TraceDataMethods">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataMethods.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="method"></param>
        </member>
        <member name="M:TypeMock.TraceDataMethods.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataMethods.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataMethods.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:TypeMock.TraceDataMethods.Method">
            <summary>
            
            </summary>
        </member>
        <member name="M:TypeMock.TraceDataHidden.#ctor(TypeMock.TraceDataMethods)">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:TypeMock.TraceDataHidden.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataHidden.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataHidden.Export">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataMockedMethods">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataMockedMethods.#ctor(System.String,TypeMock.Scope,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
        </member>
        <member name="M:TypeMock.TraceDataMockedMethods.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataMockedMethods.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataMockedMethods.Scope">
            <summary>
            
            </summary>
        </member>
        <member name="P:TypeMock.TraceDataMockedMethods.InstanceNumber">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataExpectedMethods">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataExpectedMethods.#ctor(System.String,TypeMock.Scope,System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
            <param name="returnNumber"></param>
            <param name="alwaysReturn"></param>
        </member>
        <member name="M:TypeMock.TraceDataExpectedMethods.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataExpectedMethods.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataExpectedMethods.ReturnNumber">
            <summary>
            
            </summary>
        </member>
        <member name="P:TypeMock.TraceDataExpectedMethods.IsAlways">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataSet">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataSet.#ctor(System.String,TypeMock.Scope,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
            <param name="returnNumber"></param>
            <param name="times"></param>
        </member>
        <member name="M:TypeMock.TraceDataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataSet.#ctor(System.String,TypeMock.Scope,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
        </member>
        <member name="P:TypeMock.TraceDataSet.Times">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataReSet">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataReSet.#ctor(System.String,TypeMock.Scope,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
            <param name="returnNumber"></param>
            <param name="times"></param>
        </member>
        <member name="M:TypeMock.TraceDataReSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataReSet.#ctor(System.String,TypeMock.Scope,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
        </member>
        <member name="T:TypeMock.TraceDataCalled">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataCalled.#ctor(System.String,TypeMock.Scope,System.Int32,System.String,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
            <param name="returnNumber"></param>
            <param name="passed"></param>
            <param name="isAlways"></param>
            <param name="isConditional"></param>
        </member>
        <member name="M:TypeMock.TraceDataCalled.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:TypeMock.TraceDataCalled.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization function.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:TypeMock.TraceDataCalled.HasPassed">
            <summary>
            
            </summary>
        </member>
        <member name="P:TypeMock.TraceDataCalled.IsConditional">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.TraceDataCalledUnmocked">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataCalledUnmocked.#ctor(System.String,TypeMock.Scope,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
        </member>
        <member name="M:TypeMock.TraceDataCalledUnmocked.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TypeMock.TraceDataCalledUnmockedInstance">
            <exclude/>
        </member>
        <member name="M:TypeMock.TraceDataCalledUnmockedInstance.#ctor(System.String,TypeMock.Scope,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="scope"></param>
            <param name="instanceNumber"></param>
            <param name="method"></param>
        </member>
        <member name="M:TypeMock.TraceDataCalledUnmockedInstance.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:TypeMock.AboutMessage">
            <summary>
            Summary description for AboutMessage.
            </summary>
        </member>
        <member name="T:TypeMock.Generic">
            <summary>
            This class helps strongly type generic method types when using Reflective Mocks
            </summary>
            <remarks>
            Following is an example of using Generic
            <example>
            <code>
            [Test]
            public void MockGenericMethod()
            {
               Mock mock = Mock&lt;MockedClass>.MockNextInstance();
               mock.AlwaysReturn("Method", 11, Generic.Method&lt;int>());
               MockedClass test = new MockedClass();
               Assert.AreEqual(11, test.Method&lt;int>(1));
            }
            </code>
            <code lang="VB">
            &lt;Test()&gt; _
            Public Sub MockGenericMethod()
               Dim mock As Mock = Mock(Of MockedClass).MockNextInstance()
               mock.AlwaysReturn("Method", 11, Generic.Method(Of Integer)());
               Assert.AreEqual(11, test.Method(Of Integer)(1));
            End Sub
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:TypeMock.Generic.Method``1">
            <summary>
            Define Expectations of Generic Methods with 1 generic parameter
            </summary>
            <typeparam name="TArg0">Method Generic Parameter</typeparam>
            <returns>Types of generic parameters</returns>
            <remarks>
            See <see cref="T:TypeMock.Generic"/> for an example
            </remarks>
        </member>
        <member name="M:TypeMock.Generic.Method``2">
            <summary>
            Define Expectations of Generic Methods with 2 generic parameter
            </summary>
            <typeparam name="TArg0">Method Generic Parameter 1</typeparam>
            <typeparam name="TArg1">Method Generic Parameter 2</typeparam>
            <returns>Types of generic parameters</returns>
            <remarks>
            See <see cref="T:TypeMock.Generic"/> for an example
            </remarks>
        </member>
        <member name="M:TypeMock.Generic.Method``3">
            <summary>
            Define Expectations of Generic Methods with 3 generic parameter
            </summary>
            <typeparam name="TArg0">Method Generic Parameter 1</typeparam>
            <typeparam name="TArg1">Method Generic Parameter 2</typeparam>
            <typeparam name="TArg2">Method Generic Parameter 3</typeparam>
            <returns>Types of generic parameters</returns>
            <remarks>
            See <see cref="T:TypeMock.Generic"/> for an example
            </remarks>
        </member>
        <member name="M:TypeMock.Generic.Method``4">
            <summary>
            Define Expectations of Generic Methods with 4 generic parameter
            </summary>
            <typeparam name="TArg0">Method Generic Parameter 1</typeparam>
            <typeparam name="TArg1">Method Generic Parameter 2</typeparam>
            <typeparam name="TArg2">Method Generic Parameter 3</typeparam>
            <typeparam name="TArg3">Method Generic Parameter 4</typeparam>
            <returns>Types of generic parameters</returns>
            <remarks>
            See <see cref="T:TypeMock.Generic"/> for an example
            </remarks>
        </member>
        <member name="T:ThreadMessaging.MemoryMappedFile">
            <exclude/>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedFile.CreateFile(System.String,ThreadMessaging.MemoryMappedFile.FileAccess,System.Int32)">
            <summary>
            Create a virtual memory mapped file located in the system page file.
            </summary>
            <param name="name">The name of the file. Prefix it with "Global\" or "Local\" to control its scope between NT services and user applications in Terminal Server scenarios.</param>
            <param name="access">Whether you need write access to the file.</param>
            <param name="size">The preferred size of the file in terms of bytes.</param>
            <returns>A MemoryMappedFile instance representing the file.</returns>
        </member>
        <member name="M:ThreadMessaging.MemoryMappedFile.CreateView(System.Int32,System.Int32,ThreadMessaging.MemoryMappedFileView.ViewAccess)">
            <summary>
            Create a view of the memory mapped file, allowing to read/write bytes.
            </summary>
            <param name="offset">An optional offset to the file.</param>
            <param name="size">The size of the view in terms of bytes.</param>
            <param name="access">Whether you need write access to the view.</param>
            <returns>A MemoryMappedFileView instance representing the view.</returns>
        </member>
        <member name="T:TypeMock.DecoratorAttribute">
            <summary>
            This is the base class for all decorator attributes.
            In order to implement a custom attribute, need to subclass DecoratorAttribute and implement the
            abstract method execute. 
            </summary>
            <remarks>
            The custom attribute can control the flow of the call to the original method by 
            calling the CallOriginalMethod method during the execute method.
            In any case even if the original method is not activated by the custom attribute it will be run by the decorator
            framework
            </remarks>
        </member>
        <member name="F:TypeMock.DecoratorAttribute.m_Decorator">
            <summary>
            Referance to the decorator object which holds data of the original method
            </summary>
        </member>
        <member name="F:TypeMock.DecoratorAttribute.m_DecoratedMethod">
            <summary>
            The method that is decorated by the attribute.
            </summary>
        </member>
        <member name="M:TypeMock.DecoratorAttribute.Execute">
            <summary>
                The propriety logic of the attribute should be implemented in the execute. The
                custom attribute can control the flow of the call to the original method by calling
                the CallOriginalMethod method during the execute method. In any case even if the
                original method is not activated by the custom attribute it will be run by the
                decorator framework, unless the attribute specifically asked that the original
                method will not be called using the
                <see cref="M:TypeMock.DecoratorAttribute.DontCallDecoratedMethod">DontCallDecoratedMethod Method</see>
            </summary>
            <returns>The results from activating the original invoker on the test (unless overridden)</returns>
        </member>
        <member name="M:TypeMock.DecoratorAttribute.Decorate(TypeMock.MethodDecorator,TypeMock.ExecutionDelegator)">
            <summary>
            Replace the call to the original method with the call to the attribute execute, storing all needed information
            </summary>
            <param name="decorator">The MethodDecorator instance which holds the original method data</param>
            <param name="methodToDecorate">The method that needs to be decorated</param>
            <returns>ExecutionDelegator representing the method after decoration</returns>
        </member>
        <member name="M:TypeMock.DecoratorAttribute.DecorateMethodWhenAttributeIsClass(System.Reflection.MethodBase)">
            <summary>
            Filter which methods to Execute the code, when the attribute is on a Class
            </summary>
            <param name="methodBase">method being executed</param>
            <returns>true to wrap the code</returns>
            <remarks>Default action is to apply class decorators only on test methods 
            i.e. methods that are decorated with [Test] or [TestMethod] attribute on them as well</remarks>
        </member>
        <member name="M:TypeMock.DecoratorAttribute.CallDecoratedMethod">
            <summary>
            Activate the original (decorated) method.
            </summary>
            <returns>The results from activating the original method</returns>
        </member>
        <member name="M:TypeMock.DecoratorAttribute.DontCallDecoratedMethod">
            <summary>
                Stops the decorator from calling the original method which is called automatically
                even when <see cref="M:TypeMock.DecoratorAttribute.Execute">Execute</see> method fails to call
                <see cref="M:TypeMock.DecoratorAttribute.CallDecoratedMethod">CallDecoratedMethod</see>.
            </summary>
            <remarks>If original method is decorated by another attribute and
            explicitly called there. It will be
            activated</remarks>
        </member>
        <member name="P:TypeMock.DecoratorAttribute.OriginalMethod">
            <summary>
            Retrieves the Original method info (the method which is tagged by the attribute)
            </summary>
        </member>
        <member name="P:TypeMock.DecoratorAttribute.OriginalContext">
            <summary>
            Retrieves the instance that the original method was called with.
            </summary>
        </member>
        <member name="P:TypeMock.DecoratorAttribute.OriginalParams">
            <summary>
            Retrieves the original parameters that were passed to the original method
            </summary>
        </member>
        <member name="T:TypeMock.MockMethodCallEventArgs">
            <summary>
            Event arguments that are received for the MockMethodCalled.
            </summary>
            <remarks>
            To set an event per method see <see cref="T:TypeMock.IMethodSettings"/> and Mock.<see cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            To set a global event for a mocked type see Mock.<see cref="E:TypeMock.Mock.MockMethodCalled"/>
            <seealso cref="E:TypeMock.Mock.MockMethodCalled"/>
            <seealso cref="M:TypeMock.Mock.MethodSettings(System.String)"/>
            <seealso cref="T:TypeMock.IMethodSettings"/>
            </remarks>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.CalledType">
            <summary>
            Type in which the method was called from
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.CalledMethodName">
            <summary>
            Name of method that was called
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.SentArguments">
            <summary>
            Array of the Argument that where went
            </summary>
            <remarks>
            The arguments are read only, setting these to other values will not change the arguments.
            To assign other values see <see cref="T:TypeMock.Assign"/>
            </remarks>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.ExpectedArguments">
            <summary>
            Array of the expected arguments sent to the Args method (see <see cref="T:TypeMock.IParameters"/> )
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.WillThrowException">
            <summary>
            This is true if the mocked method will throw an exception,
            Either because the exception was mocked (see <see cref="M:TypeMock.Mock.ExpectAndThrow(System.String,System.Exception,System.Type[])"/> or
            because of a validation exception.
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.Exception">
            <summary>
            This is the exception that will be thrown (null unless <see cref="P:TypeMock.MockMethodCallEventArgs.WillThrowException"/> 
            is true.
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.ReturnValue">
            <summary>
            The mocked return value (null if <see cref="P:TypeMock.MockMethodCallEventArgs.WillThrowException"/> is true)
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.HasPassedValidation">
            <summary>
            This is true if the method has passed all validations
            </summary>
        </member>
        <member name="P:TypeMock.MockMethodCallEventArgs.IsStaticMethod">
            <summary>
            This is true if the method is static
            </summary>
        </member>
        <member name="T:TypeMock.RecordExpectations">
            <summary>
            Typemock Isolator Natural Mocks™ RecordExpectations class helps define the mocked expectations
            </summary>
            <remarks>
            <para>
            Typemock Isolator supports the innovative Natural Mocks™ way of defining expectations by recording the expectations.
            Natural Mocks™ are Strongly Typed and thus supports Compile Time Checks and Refactoring. 
            Using Natural Mocks™ it is now much simpler to define and create tests that require isolating other parts of the code. 
            Although the Natural Mocks™ is easier, it does not cover all the scenarios, and the normal TyepMock.NET way is required. 
            The two way are compatible and can be used together. 
            </para>
            <para>
            <example>
            Example of using Natural Mocks™
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   TestedClass.MyMethod(10);
                }
                
                // run our code, This will be mocked 
            	TestedClass.MyMethod(10);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod(10)
                End Using
            
                '  run our code, This will be mocked 
            	TestedClass.MyMethod(10)
            	MockManager.Verify()
            End Sub
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 1.1
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Dim recorder As New RecordExpectations 
                ' CAUTION: ALL calls here are mocked!!!
                Try
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod(10)
                Finally
                   recorder.Dispose()
                End Try 
            
                '  run our code, This will be mocked 
            	TestedClass.MyMethod(10)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </para>
            See <see cref="M:TypeMock.RecordExpectations.Return(System.Object)"/> and <see cref="M:TypeMock.RecordExpectations.Throw(System.Exception)"/> to return different values
            </remarks>
            <seealso cref="M:TypeMock.RecordExpectations.Return(System.Object)"/><seealso cref="M:TypeMock.RecordExpectations.Throw(System.Exception)"/>
        </member>
        <member name="M:TypeMock.RecordExpectations.#ctor">
            <summary>
            Start a new recording, CAUTION, as long as the recording object is alive ALL methods will be recorded and not called
            </summary>
            <remarks>
            <note>
            CAUTION, as long as the recording object is alive ALL methods will be recorded and not called
            </note></remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.Return(System.Object)">
            <summary>
            Mock a return value
            </summary>
            <param name="returnValue">The mocked return value</param>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ Return
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   TestedClass.MyMethod();
                   recorder.Return(5);
                }
                
                // run our code, This will be mocked 
            	int actual = TestedClass.MyMethod();
                Assert.AreEqual(5,actual);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod()
                   recorder.Return(5)
                End Using
            
                '  run our code, This will be mocked 
            	Dim actual as Integer = TestedClass.MyMethod()
                Assert.AreEqual(5,actual)
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.ReturnDefaultImplementation">
            <summary>
            Set the mocked method to return a mock object with default behavior
            </summary>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            The default behavior is:
            <list>
            <item> All void calls just return </item>
            <item> Other Methods will return a default value (0 or null depending on the return type) </item>
            <item> Properties will behave like simple properties. </item>
            </list>
            <para>
            <example>
            Example of using Natural Mocks™ Return
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   TestedClass.MyMethod();
                   recorder.ReturnDefaultImplementation();
                }
                
                // run our code, This will be mocked 
            	int actual = TestedClass.MyMethod();
                Assert.AreEqual(0,actual);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod()
                   recorder.ReturnDefaultImplementation()
                End Using
            
                '  run our code, This will be mocked 
            	Dim actual as Integer = TestedClass.MyMethod()
                Assert.AreEqual(0,actual)
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.Do(TypeMock.DynamicReturnValue)">
            <summary>
            Mock a return value
            </summary>
            <param name="func">Function to perform</param>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ Do
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   TestedClass.MyMethod();
                   recorder.Do(delegate(object[] parameters, object context)
                   {
                       return 5;
                   });
                }
                
                // run our code, This will be mocked 
            	int actual = TestedClass.MyMethod();
                Assert.AreEqual(5,actual);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            Public Function ReturnValue(ByVal parameters() As Object, ByVal context As Object) As Object 
               ReturnValue = 5
            End function
            End Class
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod()
                   recorder.Do(AddressOf ReturnValue)
                End Using
            
                '  run our code, This will be mocked 
            	Dim actual as Integer = TestedClass.MyMethod()
                Assert.AreEqual(5,actual)
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.ExpectAndReturn(System.Object,System.Object)">
            <summary>
            Expect a call and Mock a return value
            </summary>
            <param name="mockedStatements">The call(s) to be mocked</param>
            <param name="returnValue">The mocked return value</param>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ ExpectAndReturn
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   recorder.ExpectAndReturn(TestedClass.MyMethod(),5);
                }
                
                // run our code, This will be mocked 
            	int actual = TestedClass.MyMethod();
                Assert.AreEqual(5,actual);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   recorder.ExpectAndReturn(TestedClass.MyMethod(),5)
                End Using
            
                '  run our code, This will be mocked 
            	Dim actual as Integer = TestedClass.MyMethod()
                Assert.AreEqual(5,actual)
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.Throw(System.Exception)">
            <summary>
            Mock throwing an exception
            </summary>
            <param name="mockedException">The exception to throw when the method has been called </param>
            <remarks>See <see cref="M:TypeMock.RecordExpectations.Return(System.Object)"/> for an example</remarks>
            <returns>Ability to modify mock Behavior</returns>
        </member>
        <member name="M:TypeMock.RecordExpectations.ExpectAndThrow(System.Object,System.Exception)">
            <summary>
            Expect a call and mock throwing an exception
            </summary>
            <param name="mockedStatements">The call(s) to be mocked</param>
            <param name="mockedException">The exception to throw when the method has been called</param>
            <remarks>See <see cref="M:TypeMock.RecordExpectations.Return(System.Object)"/> for an example</remarks>
            <returns>Ability to modify mock Behavior</returns>
        </member>
        <member name="M:TypeMock.RecordExpectations.CallOriginal">
            <summary>
            Expect a call but call the original method
            </summary>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ CallOriginal
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   TestedClass.MyMethod();
                   recorder.CallOriginal();
                }
                
                // run our code, This will not be mocked but we verify that it was called
            	TestedClass.MyMethod();
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   TestedClass.MyMethod()
                   recorder.CallOriginal()
                End Using
            
                '  run our code, This will not be mocked but we verify that it was called 
            	TestedClass.MyMethod()
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.ExpectAndCallOriginal(System.Object)">
            <summary>
            Expect a call but call the original method
            </summary>
            <param name="mockedStatements">The call(s) to be mocked</param>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ ExpectAndCallOriginal
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod will be mocked.
                   recorder.ExpectAndCallOriginal(TestedClass.MyMethod());
                }
                
                // run our code, This will not be mocked but we verify that it was called
            	TestedClass.MyMethod();
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod will be mocked.
                   recorder.ExpectAndCallOriginal(TestedClass.MyMethod())
                End Using
            
                '  run our code, This will not be mocked but we verify that it was called 
            	TestedClass.MyMethod()
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.FailWhenCalled(System.Object)">
            <summary>
            Fail if the call is made 
            </summary>
            <param name="mockedStatement">The call to be mocked</param>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ FailWhenCalled
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod cannot be called.
                   recorder.FailWhenCalled(TestedClass.MyMethod());
                }
                
                // run our code, This will fail 
            	int actual = TestedClass.MyMethod();
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod cannot be called.
                   recorder.FailWhenCalled(TestedClass.MyMethod())
                End Using
            
                '  run our code, This will fail 
            	Dim actual as Integer = TestedClass.MyMethod()
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.FailWhenCalled">
            <summary>
            Fail when the last call is made 
            </summary>
            <returns>Ability to modify mock Behavior</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ FailWhenCalled
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // MyMethod cannot be called.
                   TestedClass.MyMethod()
                   recorder.FailWhenCalled();
                }
                
                // run our code, This will fail 
            	int actual = TestedClass.MyMethod();
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' MyMethod cannot be called.
                   TestedClass.MyMethod()
                   recorder.FailWhenCalled()
                End Using
            
                '  run our code, This will fail 
            	Dim actual as Integer = TestedClass.MyMethod()
            	MockManager.Verify()
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.MockStaticConstructors">
            <summary>
            Mock the static constructors of the previously created instance
            </summary>
            <remarks>
            By default, Typemock Isolator automatically mocks the static constructors 
            of instances created inside recording blocks. 
            These static constructors are activated either when an un-mocked call 
            is made on the type in another test, or when a new
            un-mocked instance from the type is created.
            </remarks>
        </member>
        <member name="M:TypeMock.RecordExpectations.CallStaticConstructors">
            <summary>
            Instruct the framework to not mock the static constructor of the previously created instance.
            In order to stop mocking of all static constructors, us the DefaultBehavior.MockStaticConstructors
            </summary>
        </member>
        <member name="M:TypeMock.RecordExpectations.AssignField(System.Object@,System.Object)">
            <summary>
            Assign a new value to the given field on the future created object.
            </summary>
            <param name="field">Referance to the field to be assigned.</param>
            <param name="newValue">The value to assign.</param>
            <example>
            Show how to assign values to a field during the recording mode and how the value is 
            reflected on the new object created during the test.
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void FieldAssignmentNatural()
            {
               FieldClass replacement = new FieldClass();
               using (RecordExpectations recorder = new RecordExpectations())
               {
                   //create a mock and assign a future value to the intMember
                   TestedClass mock = new TestedClass();
                   recorder.AssignField(ref mock.classField, replacement);
               }
               //verify that the replaced value was assigned to the newly created instance
               TestedClass target = new TestedClass();
               int actual = target.classField.GetHashCode();
               Assert.AreEqual(replacement.GetHashCode(), actual);        
            }
            </code>
            <code>
            //VB
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub FieldAssignmentNatural()
                Dim replacement As new FieldClass
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' make all future instances mocked
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   ' always return 10
                   recorder.AssignField(ref mock.classField, replacement)
                End Using
                ' verify that the replaced value was assigned to the newly crated instance
                Dim target As New TestedClass
                Dim actual As Integer = target.classField.GetHashCode()
                Assert.AreEqual(Replacement.GetHashCode, actual)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:TypeMock.RecordExpectations.AssignField``1(``0@,``0)">
            <summary>
            Assign a new value to the given field on the future created object.
            </summary>
            <param name="field">Referance to the field to be assigned.</param>
            <param name="newValue">The value to assign.</param>
            <example>
            Show how to assign values to a field during the recording mode and how the value is 
            reflected on the new object created during the test.
            <code lang="cs">
            [Test]
            [VerifyMocks]
            public void FieldAssignmentNatural()
            {
               using (RecordExpectations recorder = new RecordExpectations())
               {
                   //create a mock and assign a future value to the intMember
                   TestedClass mock = new TestedClass();
                   recorder.AssignField(ref mock.intMember, 7);
               }
               //verify that the replaced value was assigned to the newly created instance
               TestedClass target = new TestedClass();
               Assert.AreEqual(7, target.intMember);
            }
            </code>
            <code lang="vbnet">
            &lt;Test(), VerifyMocks() &gt; _
            Public Sub FieldAssignmentNatural()
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' make all future instances mocked
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.DoSomething()
                   ' always return 10
                   recorder.AssignField(ref mock.intMember, 7)
                End Using
                ' verify that the replaced value was assigned to the newly crated instance
                Dim target As New TestedClass
                Assert.AreEqual(7, target.intMember)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:TypeMock.RecordExpectations.Dispose">
            <summary>
            Stop RecordExpectations, all methods will be called or mocked
            </summary>
        </member>
        <member name="M:TypeMock.RecordExpectations.IgnoreArguments">
            <summary>
            See <see cref="M:TypeMock.IMockBehavior.IgnoreArguments"/>
            </summary>
        </member>
        <member name="M:TypeMock.RecordExpectations.CheckArguments(System.Object[])">
            <summary>
            See <see cref="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])"/>
            </summary>
            <param name="args">list of expected parameters and/or parameter checkers</param>
        </member>
        <member name="M:TypeMock.RecordExpectations.WhenArgumentsMatch(System.Object[])">
            <summary>
            See <see cref="M:TypeMock.IMockBehavior.WhenArgumentsMatch(System.Object[])"/>
            </summary>
            <param name="args">list of expected parameters and/or parameter checkers</param>
        </member>
        <member name="M:TypeMock.RecordExpectations.Repeat(System.Int32)">
            <summary>
             See <see cref="M:TypeMock.IMockBehavior.Repeat(System.Int32)"/>
            </summary>
            <param name="timesToRun">Amount of times to repeat the expectation</param>
            <returns>Use to change mock Behavior</returns>
        </member>
        <member name="M:TypeMock.RecordExpectations.RepeatAlways">
            <summary>
            See <see cref="M:TypeMock.IMockBehavior.RepeatAlways"/>
            </summary>
            <returns>Use to change mock Behavior</returns>
        </member>
        <member name="P:TypeMock.RecordExpectations.MockAllInstances">
            <summary>
            Mock all future instances of the type mocked
            </summary>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ MockAllInstances, 
            we will always return 10 when DoSomething is called from any TestedClass instance
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // make all future instances mocked
                   recorder.MockAllInstances = true;
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.DoSomething();
                   // always return 10
                   recorder.Return(10).RepeatAlways();
                }
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' make all future instances mocked
                   recorder.MockAllInstances = True
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.DoSomething()
                   ' always return 10
                   recorder.Return(10).RepeatAlways()
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="P:TypeMock.RecordExpectations.VerifyMode">
            <summary>
            Change the verify mode of the next expectations
            </summary>
        </member>
        <member name="P:TypeMock.RecordExpectations.DefaultBehavior">
            <summary>
            Change the default Behavior of Natural Mocks™
            </summary>
            <remarks>
            The default Behavior of Natural Mocks is
            <list type="bullet">
            <item>Repeat once (See <see cref="M:TypeMock.IMockBehavior.Repeat(System.Int32)"/>)</item> 
            <item>Ignore Arguments (See <see cref="M:TypeMock.IMockBehavior.IgnoreArguments"/>)</item>
            </list>
            To change this use DefaultBehavior.
            This is useful for chained natural mocks where we require the whole chain to be checked.
            <para>
            <example>
            Example of using Natural Mocks™ repeat always, 
            we will always return 10 when GetSomething().DoSomething() is called from any TestedClass instance
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // make all future instances mocked and all statements repeat
                   recorder.DefaultBehavior.RepeatAlways();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething().DoSomething();
                   // always return 10
                   recorder.Return(10);
                }
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' make all future instances mocked and all statements repeat
                   recorder.DefaultBehavior.RepeatAlways()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething().DoSomething()
                   ' always return 10
                   recorder.Return(10)
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>       
        </member>
        <member name="T:TypeMock.About">
            <summary>
            Summary description for About.
            </summary>
        </member>
        <member name="M:TypeMock.About.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:TypeMock.About.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:ThreadMessaging.NTKernel">
            <exclude/>
        </member>
        <member name="T:TypeMock.StringCheck">
            <summary>
            Summary description for StringCheck.
            </summary>
        </member>
        <member name="T:TypeMock.StateFullDelegate">
            <summary>
            Summary description for StateFullDelegate.
            </summary>
        </member>
        <member name="T:TypeMock.CompoundCheck">
            <summary>
            Summary description for CompoundCheck.
            </summary>
        </member>
        <member name="T:TypeMock.VerifyMocksAttribute">
             <summary> Used to initiate verification at the end of each test. This class cant
             be inherited. </summary>
             <remarks>Any method marks with this attribute will call MockManager.Verify after
             the test is done. A marked class will do this for any test defined in
             it.</remarks>
             <example>
             <code lang="cs">
             [TestFixture] 
             [ClearMocks] // clear all mocks between tests
             public TestClass
             {
                 [Test]
                 [VerifyMocks] // verify the mocks after this tests
                 void test1()
                 {
                     // Set Expectations
            
                     // the test code
                 }
             }</code>
             <code lang="vbnet">
             &lt; TestFixture &gt;_
             &lt; ClearMocks &gt;_ ' clear all mocks between tests
             Public class TestClass
                 &lt; Test &gt;_
                 &lt; VerifyMocks &gt;_ ' verify the mocks after this tests
                 Public Sub test1()
                    ' Set expectations
             
                    ' the test code
                 End Sub
             End Class</code></example>
             <seealso cref="T:TypeMock.VerifyMocksAttribute">ClearMocksAttribute</seealso>
             <seealso cref="M:TypeMock.MockManager.Verify">MockManager.Verify</seealso>
        </member>
        <member name="M:TypeMock.VerifyMocksAttribute.#ctor">
            <summary>
            Create an instance of the attribute.
            when this attribute is specified the mock verification process will be initiated automatically
            at the end of the test method (when specified on a class it will be done for each test method)
            </summary>
        </member>
        <member name="M:TypeMock.VerifyMocksAttribute.#ctor(System.Int32)">
            <summary>
            Create an instance of the attribute, initializing it with the given timeout.
            When a timeout is specified the auto verify will call the verification with timeout process.
            </summary>
            <param name="timeout">the given timeout (in milliseconds)</param>
        </member>
        <member name="M:TypeMock.VerifyMocksAttribute.Execute">
            Called by the framework instead of the original method. This will run the original method and 
            afterwards will initiate the verification process.
            <remarks>If the test has failed on its own, verification will not be called but all expectations will be cleared
            anyway.</remarks>
            <returns>The results from activating the original invoker on the test</returns>
            <exception cref="T:TypeMock.VerifyException">if verify fails</exception>
        </member>
        <member name="P:TypeMock.VerifyMocksAttribute.Timeout">
            <summary>
            Get and Set the timeout (in milliseconds) for all expectations to complete
            </summary>
        </member>
        <member name="T:TypeMock.MethodDecorator">
            <summary>
            Implement the logic which activate the decorating attributes.
            </summary>
        </member>
        <member name="F:TypeMock.MethodDecorator.m_OriginalMethod">
            <summary>
            holds the Decorated method (i.e. method which is tagged by the custom attribute)
            </summary>
        </member>
        <member name="F:TypeMock.MethodDecorator.m_OriginalContext">
            <summary>
            stores the instance that the decorated method was called with
            </summary>
        </member>
        <member name="F:TypeMock.MethodDecorator.m_OriginalParams">
            <summary>
            stores the original parameters to pass to the decorated method
            </summary>
        </member>
        <member name="F:TypeMock.MethodDecorator.m_DecoratingAttributes">
            <summary>
            holds all the attributes decorating the method
            </summary>
        </member>
        <member name="F:TypeMock.MethodDecorator.OriginalWasCalled">
            <summary>
            specify if the original method was called or not during the execution flow
            </summary>
        </member>
        <member name="F:TypeMock.MethodDecorator.IgnoreOriginalCalled">
            <summary>
            specify if the original method can be ignored
            </summary>
        </member>
        <member name="M:TypeMock.MethodDecorator.#ctor(System.Reflection.MethodBase,System.Object,System.Object[])">
            <summary>
            default ctor. initialize the context,method,attributes,par
            </summary>
            <param name="method">The method to decorate(i.e. the method which is tagged by the attribute)</param>
            <param name="context">The instance that the decorated method was called through</param>
            <param name="par">the parameters to pass to the decorated method</param>
        </member>
        <member name="M:TypeMock.MethodDecorator.GetDecoratingAttributes(System.Reflection.MethodBase)">
            <summary>
            Returns all the custom attributes (i.e. sub classes of DecoratorAttribute) that surrounds the method
            </summary>
            <param name="method">The method </param>
            <returns>array of the decorating attributes</returns>
        </member>
        <member name="M:TypeMock.MethodDecorator.Run">
            <summary>
            Activate the execution flow of the decorating attributes
            </summary>
            <returns>The results from activating the original invoker on the test (unless overridden)</returns>
        </member>
        <member name="M:TypeMock.MethodDecorator.DontCallDecoratedMethod">
            <summary>
            Tell the decorator not to check if the decorated method was called from the 
            attributes. this means that if the attribute didnt call the decorated method 
            it wont be executed at all.
            </summary>
        </member>
        <member name="P:TypeMock.MethodDecorator.OriginalMethod">
            <summary>
            Retrieves the Original method info (the method which is tagged by the attribute)
            </summary>
        </member>
        <member name="P:TypeMock.MethodDecorator.OriginalContext">
            <summary>
            Retrieves the instance that the original method was called with.
            </summary>
        </member>
        <member name="P:TypeMock.MethodDecorator.OriginalParams">
            <summary>
            Retrieves the original parameters that were passed to the original method
            </summary>
        </member>
        <member name="T:TypeMock.MethodCallContext">
            <summary>
            Class that contains information about the called instance 
            </summary>
        </member>
        <member name="M:TypeMock.MethodCallContext.TypeMock#ArrangeActAssert#IHideObjectMethods#GetType">
            <summary>
            Class that contains information about the called instance 
            </summary>
        </member>
        <member name="P:TypeMock.MethodCallContext.Instance">
            <summary>
            Reference to the mocked object instance, or null if the method is static
            </summary>
            <value>The instance.</value>
        </member>
        <member name="P:TypeMock.MethodCallContext.Parameters">
            <summary>
            Array of parameters passed to mocked method
            </summary>
            <value>The parameters.</value>
        </member>
        <member name="T:TypeMock.InternalMockManager">
            <exclude/>
            <summary>
            Static methods called by instrumented code, This class delegated to <see cref="T:TypeMock.MockManager"/>
            who holds all the data. It is used to hide the runtime methods from nUnit users
            </summary>
            <remarks>
            <note>
            <c>getReturn</c> is overloaded many times to make the instrumented code easier to implement,
            if we would have used <c>param object[]</c> we would have to use a local variable and
            recalculate the local variable table, this way we just have to find the token for the 
            correct overloaded method. See <c>CProfilerCallback::JITCompilationStarted</c>
            </note>
            </remarks>
        </member>
        <member name="M:TypeMock.InternalMockManager.GetRefParameter(System.Object,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Internal use only Get a parameter if changed
            </summary>
            <param name="parameterNumber">number of parameter</param>
            <param name="methodName"></param>
            <param name="typeName"></param>
            <returns>Value of changed parameter</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.ClearRefParameter(System.Object,System.String,System.String,System.Boolean)">
            <summary>
            Internal use only Reset the ref parameters. Required to be called after each mock
            </summary>
            <param name="methodName"></param>
            <param name="typeName"></param>
        </member>
        <member name="M:TypeMock.InternalMockManager.AssignParameter(System.Object,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Internal use only Assign parameter
            </summary>
            <param name="parameterNumber">number of parameter</param>
            <param name="methodName"></param>
            <param name="typeName"></param>
            <returns>Value of changed parameter</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.Clover">
            <summary>
            Internal use only
            </summary>
        </member>
        <member name="M:TypeMock.InternalMockManager.isMocked(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean)">
            <param name="methodParameters"></param>
            <param name="isInjected"></param>
            <param name="isIntercepted"></param>
            <returns>true if the current method mocked</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.MethodReturned(System.Object,System.Object)">
            <summary>
            Internal use only called when a method is about to return
            </summary>
            <param name="returnValue"></param>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only  Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="M:TypeMock.InternalMockManager.getReturn(System.Object,System.String,System.String,System.Object,System.Boolean,System.Boolean,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Internal use only Get our return value
            </summary>
            <returns>Mocked Return Value</returns>
        </member>
        <member name="P:TypeMock.InternalMockManager.Locked">
            <summary>
            Set locked when inside Typemock Isolator code to disable infinite recurse
            </summary>
        </member>
        <member name="T:TypeMock.InternalMockManager.CONTINUE">
            <summary>
            If CONTINUE is returned the mocked method will continue with
            normal execution
            </summary>
        </member>
        <member name="F:TypeMock.InternalMockManager.CONTINUE.WITH_METHOD">
            <summary>
            Placeholder
            </summary>
        </member>
        <member name="F:TypeMock.Internal.Hooks.EventTunnel.ShouldInterceptDecision">
            <summary>
            This delegate is called when a method call is detected. Its implementation can be a filter that
            decides whether the method call will be intercepted, not intercepted, or analyzed by Isolator
            </summary>
        </member>
        <member name="F:TypeMock.Internal.Hooks.EventTunnel.DuringMethodCall">
            <summary>
            This delegate is called after a method has been intercepted. Its implementation can be a filter
            that decides how to handle the call: return a custom value, throw an exception, skip the method
            altogether, or let Isolator decide
            </summary>
        </member>
        <member name="T:TypeMock.RecorderManager">
            <summary>
            Typemock Isolator Natural Mocks™ RecorderManager class helps manage the mocks
            </summary>
            <remarks>
            <para>
            Typemock Isolator supports the innovative Natural Mocks™ way of defining expectations by recording the expectations.
            Natural Mocks™ are Strongly Typed and thus supports Compile Time Checks and Refactoring. 
            Using Natural Mocks™ it is now much simpler to define and create tests that require isolating other parts of the code. Although the Natural Mocks™ is easier, it does not cover all the scenarios, and the normal TyepMock.NET way is required. The two way are compatible and can be used together. 
            </para>
            See <see cref="T:TypeMock.RecordExpectations"/> for examples
            </remarks>
            <seealso cref="T:TypeMock.RecordExpectations"/>
        </member>
        <member name="M:TypeMock.RecorderManager.StartRecording">
            <summary>
            Start a new recording, CAUTION, as long as the recording object is alive ALL methods will be recorded and not called
            </summary>
            <remarks>
             See <see cref="T:TypeMock.RecordExpectations"/> for usage
            <note>
            CAUTION, as long as the recording object is alive ALL methods will be recorded and not called
            </note></remarks>
            <returns>RecordExpectations object</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.StopRecording">
            <summary>
            Stop the recording
            </summary>
        </member>
        <member name="M:TypeMock.RecorderManager.GetLastRecordedMock">
            <summary>
            Get the last recorded mock and use Reflective Typemock Isolator methods.
            </summary>
            <returns>The mock</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.GetLastRecordedMockedObject">
            <summary>
            Returns the object of the last recorded mock or null if non exists
            </summary>
            <returns> a mocked object</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.GetMockOf``1(``0)">
             <summary>
             Returns the mock associated with a specific instance
             </summary>
             <typeparam name="T">Type of the instance being mocked</typeparam>
             <param name="instance">The instance to get the mock of</param>
             <returns>If a Mock is associated with the provided instance, returns it. Otherwise, returns null</returns>
             <example>
             Identify a specific mock when using Natural Mocks
             <code>
            [Test]
            public void GetMockOfSpecificInstance()
            {
                 using(RecordExpectations rec = RecorderManager.StartRecording())
                 {
                     TestClass instance1 = new TestClass();
                     TestClass instance2 = new TestClass();
                     TestClass instance3 = new TestClass();
             
                     Mock mock2 = RecorderManager.GetMockOf(instance2);
                     mock2.ExpectAndReturn("SomeMethod", null);
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)">
            <summary>
            Create a mocked object
            </summary>
            <param name="typeToMock">The type to mock</param>
            <returns>a mocked object of the type specified</returns>
            <remarks>
            <para>
            <example>
            Example of using Natural Mocks™ Return
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Create Mock Object
                ITestClass mockTestClass = RecorderManager.CreateMockedObject(typeof(ITestClass)) as ITestClass;
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // Set expectations on mocked object.
                   recorder.ExpectAndReturn(mockTestClass.MyMethod().MyProperty, 5);
                }
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Create Mock Object
                Dim mockTestClass As ITestClass = RecorderManager.CreateMockedObject(GetType(ITestClass))
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' Set expectations on mocked object.
                   recorder.ExpectAndReturn(mockTestClass.MyMethod().MyProperty, 5)
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.Constructor)">
            <summary>
            Create a mocked object and define constructor Behavior
            </summary>
            <param name="typeToMock">The type to mock</param>
            <param name="mockConstructor">Define what constructors to mock</param>
            <returns>a mocked object of the type specified</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.Constructor,TypeMock.StrictFlags)">
            <summary>
            Create a mocked object and define constructor Behavior
            </summary>
            <param name="typeToMock">The type to mock</param>
            <param name="mockConstructor">Define what constructors to mock</param>
            <param name="strictFlags">Define Arbitrary Call behavior</param>
            <returns>a mocked object of the type specified</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.Constructor,System.Object[])">
            <summary>
            Create a mocked object, define constructor Behavior and pass arguments to constructor
            </summary>
            <param name="typeToMock">The type to mock</param>
            <param name="mockConstructor">Define what constructors to mock</param>
            <param name="args">Arguments to pass to constructor</param>
            <returns>a mocked object of the type specified</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.StrictFlags,System.Object[])">
            <summary>
            Create a mocked object, define constructor Behavior and pass arguments to constructor
            </summary>
            <param name="typeToMock">The type to mock</param>
            <param name="strictFlags">Define Arbitrary Call behavior</param>
            <param name="args">Arguments to pass to constructor</param>
            <returns>a mocked object of the type specified</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.Constructor,TypeMock.StrictFlags,System.Object[])">
            <summary>
            Create a mocked object, define constructor Behavior and pass arguments to constructor
            </summary>
            <param name="typeToMock">The type to mock</param>
            <param name="mockConstructor">Define what constructors to mock</param>
            <param name="strictFlags">Define Arbitrary Call behavior</param>
            <param name="args">Arguments to pass to constructor</param>
            <returns>a mocked object of the type specified</returns>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject``1">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance
            </summary>
            <typeparam name="TMockedType">The Type to Mock</typeparam>
            <returns>The Mocked Instance</returns>
            <remarks>
            The Constructor will be mocked!. 
            <para>
            Typemock Isolator will choose a constructor with the highest visibility and create default values for the
            arguments, to send specific arguments use <see cref="!:CreateObject(Constructor,object[])"/>
            </para>
            <example>
            <code>
            [Test]
            public void MockTestedClass() 
            {
            	TestedClass mockedInstance = RecorderManager.CreateMockedObject&lt;TestedClass&gt;();
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   mockedInstance.SomeMethod(10);    // SomeMethod will be mocked.
                }
            
            	mockedInstance.SomeMethod();          // the method is not called
            
            	MockManager.Verify();                 // Make sure that all expected calls where made
            }
            </code>
            <code lang="VB">
            &lt;Test()&gt; _
            Public Sub MockTestedClass()
            	Dim mockedInstance As TestedClass = RecorderManager.CreateMockedObject(Of TestedClass)
            	' Start mocking 
                Using recorder As New RecordExpectations
                   TestedClass.SomeMethod(10)              ' SomeMethod will be mocked.
                End Using
            
            	mockedInstance.SomeMethod()                ' the method is not called
            
            	MockManager.Verify()                       ' Make sure that all expected calls where made
            End Sub
            </code>
            </example>
            <seealso cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)"/><seealso cref="T:TypeMock.MockObject"/>
            </remarks>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject``1(TypeMock.Constructor,System.Object[])">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance, send Constructor behavior and optional arguments
            </summary>
            <typeparam name="TMockedType">The Type to Mock</typeparam>
            <param name="mockConstructors">Scope of mocked constructors</param>
            <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
            <returns>The Mocked Instance</returns>
            <remarks>
            For an example see <see cref="M:TypeMock.RecorderManager.CreateMockedObject``1"/>
            <seealso cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)"/><seealso cref="T:TypeMock.MockObject"/>
            </remarks>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject``1(TypeMock.Constructor,TypeMock.StrictFlags,System.Object[])">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance, send Constructor behavior Strictness and optional arguments
            </summary>
            <typeparam name="TMockedType">The Type to Mock</typeparam>
            <param name="mockConstructors">Scope of mocked constructors</param>
            <param name="strictFlags">Define Arbitrary Call behavior</param>
            <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
            <returns>The Mocked Instance</returns>
            <remarks>
            For an example see <see cref="M:TypeMock.RecorderManager.CreateMockedObject``1"/>
            <seealso cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)"/><seealso cref="T:TypeMock.MockObject"/>
            </remarks>
        </member>
        <member name="M:TypeMock.RecorderManager.CreateMockedObject``1(TypeMock.StrictFlags,System.Object[])">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance, send Strictness and optional arguments
            </summary>
            <typeparam name="TMockedType">The Type to Mock</typeparam>
            <param name="strictFlags">Define Arbitrary Call behavior</param>
            <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
            <returns>The Mocked Instance</returns>
            <remarks>
            The Constructor will not be mocked!.
            For an example see <see cref="M:TypeMock.RecorderManager.CreateMockedObject``1"/>
            <seealso cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)"/><seealso cref="T:TypeMock.MockObject"/>
            </remarks>
        </member>
        <member name="P:TypeMock.RecorderManager.VerifyMode">
            <summary>
            Get or Set the VerifyMode of the next expectations
            </summary>
        </member>
        <member name="P:TypeMock.RecorderManager.LastMockedEvent">
            <summary>
            Retrieve the last Mocked Event <seealso cref="T:TypeMock.MockedEvent"/>
            </summary>
            <see cref="T:TypeMock.MockedEvent"/>
        </member>
        <member name="T:TypeMock.UnexpectedCallException">
            <summary>
            Thrown when call was made to a mock object but wasn't registered
            see: <see cref="P:TypeMock.Mock.Strict"/>
            </summary>
        </member>
        <member name="T:TypeMock.StrictFlags">
            <summary>
            Flags that define the behavior of Arbitrary (not expected) calls.
            The default is the Methods of Abstract and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
            <remarks>
            When testing for mock interactions there are times when the default behavior needs to be changed, 
            the StrictFlags define which arbitrary methods we allow.
            <note>
            When allowing arbitrary abstract methods (methods created dynamically by Typemock Isolator using <see cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/> or <see cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type)"/>), 
            Typemock Isolator create the following default behavior:
            1. All void calls just return
            2. Other Methods will return 0 or null depending on the return type
            3. Properties will behave like normal properties
            </note>
            <note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)"/> or <see cref="M:TypeMock.RecordExpectations.FailWhenCalled"/>
            </note>
            </remarks>
        </member>
        <member name="F:TypeMock.StrictFlags.AllMethods">
            <summary>
            All methods are strict and if an arbitrary method is called the test will fail
            This is equivalent to : StrictFlags.InstanceMethods | StrictFlags.StaticMethods
            </summary>
        </member>
        <member name="F:TypeMock.StrictFlags.InstanceMethods">
            <summary>
            Instance methods are strict and if an arbitrary instance method is called the test will fail
            </summary>
        </member>
        <member name="F:TypeMock.StrictFlags.StaticMethods">
            <summary>
            Static methods are strict and if an arbitrary static method is called the test will fail
            </summary>
        </member>
        <member name="F:TypeMock.StrictFlags.MethodsOfAbstractTypes">
            <summary>
            This is the default. Methods of Abstract classes and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
        </member>
        <member name="F:TypeMock.StrictFlags.ArbitraryMethodsAllowed">
            <summary>
            Methods are not strict and arbitrary methods are allowed
            </summary>
        </member>
        <member name="T:TypeMock.Constructor">
            <summary>
            Scope of Constructors to Mock. see MockManager.<see cref="M:TypeMock.MockManager.Mock(System.Type,TypeMock.Constructor)"/>
            </summary>
            <remarks>
            .NET code has support for two constructors the first is the normal constructor that is run 
            every time a new instance is created and the other is the static constructor that is run the
            first time the object is referenced too. This constructor sets up all the static fields.
            </remarks>
        </member>
        <member name="F:TypeMock.Constructor.Mocked">
            <summary>
            Both regular constructor and static constructors should be mocked out
            </summary>
        </member>
        <member name="F:TypeMock.Constructor.StaticNotMocked">
            <summary>
            Only regular constructors should be mocked out
            </summary>
        </member>
        <member name="F:TypeMock.Constructor.NotMocked">
            <summary>
            Both Constructors will run as normal and wont be mocked
            </summary>
        </member>
        <member name="T:TypeMock.MockManager">
            <summary>
            MockManager is the Typemock Isolator manager class, this class is the entry point
            for creating type mocks
            </summary>
            <remarks>
            <para>
            Mock object tests replace domain dependencies with mock implementations used only
            for testing. This strategy does, however, present a technical challenge in certain 
            situations, as the Mock objects can only mock interfaces, and these mocks have to 
            be passed to the function, so no internal instantiation of classes can be mocked
            </para>
            <para>
            Typemock Isolator to provide "type" mock objects. No concrete mock objects are 
            actually created, but rather Typemock Isolator is used to weave interceptions into 
            all code that is not part of the class under test. In this way, every method call 
            is intercepted. If the method call is one for which mock data has been declared, 
            then that mock data is returned in place of the actual method being run. 
            </para><para>
            For example a LoginView (the class being tested) which as properties of userID and
            password that are set prior to calling a validate method. Following that call, the 
            status attribute will be set to a string value that is ultimately displayed to the 
            user. The LoginView is responsible for interpreting the status code 
            (USER_VALID, NO_PASSWORD, NO_USERID, INVALID_USER) that is returned from an 
            AccessController, to determine the status message to display. 
            </para>
            <example>
            <code lang="cs">
            public string Validate()
            {
            	AccessController controller = new AccessController();
            	AccessStatus status = controller.Login(m_UserID,m_Password);
            	switch (status) 
            	{
            		case USER_VALID:
            			...
            	}
            	return returnStatus;
            }
            </code>
            <code lang="vbnet">
            Public Function Validate() As String
             	Dim controller As AccessController = New AccessController
            	Dim status As AccessStatus = controller.Login(m_UserID,m_Password)
            	Select Case status   
            	   Case USER_VALID
            			...
            	End Select 
            	Validate = returnStatus
            }
            </code>	{
            </example>
            <para>
            However, the LoginView class makes use of the login service provided by the 
            <c>AccessController</c> class. The AccessController will probably itself 
            use other components to authenticate the user. For the tests to work it would 
            be necessary to create some test users in the system. The tests that were written 
            to test the behavior of LoginView would in fact also be testing the 
            <c>AccessController</c>, which should of course have its own suite of tests. 
            </para>
            <para>
            The behavior we are trying to test here is to determine that the user gets the 
            correct status message for the different cases of invalid or missing user 
            credentials returned by the AccessController and not the actual validation of 
            those credentials. 
            </para>
            
            Using Typemock Isolator We can intercept the <c>AccessController</c> and 
            return our own value
            <example>
            <code lang="cs">
            [Test]
            public void ValidateValidUser()
            {
            	//Mock all invocation of AccessController, all calls to this class, are 
            	//intercepted.
            	Mock mock = MockManager.Mock(typeof(AccessController));
            
            	//We expect that the login method will be called (once) and we will return 
            	//AccessStatus.INVALID_USER.
            	mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER);
            
            	LoginView view = new LoginView();
            	view.setUserID("jane");
            	view.setPassword("passAugust");
            	// run the method being tested
            	view.Validate();
            	Assert.AreEqual("login successful", view.Status);
            
            	// Verify that all the expected calls have actually been called.
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub ValidateValidUser()
            	' Mock all invocation of AccessController, all calls to this class, are 
            	' intercepted.
            	Dim mock As Mock = MockManager.Mock(GetType(AccessController))
            
            	' We expect that the login method will be called (once) and we will return 
            	' AccessStatus.INVALID_USER.
            	mock.ExpectAndReturn("Login", AccessStatus.INVALID_USER)
            
            	Dim view As LoginView = New LoginView
            	view.setUserID("jane")
            	view.setPassword("passAugust")
            	' run the method being tested
            	view.Validate()
            	Assert.AreEqual("login successful", view.Status)
            
            	' Verify that all the expected calls have actually been called.
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            <para>
            <note>
            To enable mock manager do one of the following
            <list type="number">
            <item>
            Run mocking_on.bat
            </item>
            <item>
            Run Typemock Isolator [application]
            </item>
            <item>
            Enable Visual Studio Plugin
            </item>
            </list>
            </note>
            </para>
            </remarks>
        </member>
        <member name="F:TypeMock.MockManager.DynamicMocksAssembly">
            Strong Name for Typemock Isolator Dynamic Objects can be used when mocking internal interfaces
            Use for [assembly: InternalsVisibleTo(MockManager.DynamicMocksAssembly)] 
            This will work for both regular and signed assemblies
            When you don't want to reference TypeMock.dll use the following:
            [assembly: InternalsVisibleTo("DynamicMockAssembly,PublicKey=0024000004800000940000000602000000240000525341310004000001000100ab8e3015b99a732d20ecb2a29fb3f54288a8a614896e7c5091d7b9045368fe6b8bfcc72dce4f01b71281eb4e380dcb709c83a5042a54c684a4711248c078fefb01bcdb09a6ce252e0304ed08c6e4ddf69212e3d0a770d953572e3c474fc08fe3bdbb2fad97b32c6045c08f34466dc8e07bd255d3dbc72408dce6859edb4b04bf")]
        </member>
        <member name="F:TypeMock.MockManager.m_InDecoratedCodeImplementation">
            <summary>
            mean that we are in the implementation of the decoration code
            </summary>
        </member>
        <member name="M:TypeMock.MockManager.#ctor">
            <summary>
            Disallow creation on instance
            </summary>
        </member>
        <member name="F:TypeMock.MockManager.mockedTypes">
            <summary>
            Stores all classes (with all inheriteance hirarchy) that user has requested to mock.
            </summary>
        </member>
        <member name="F:TypeMock.MockManager.m_CallCounterMap">
            <summary>
            Stores counters for all method calls
            </summary>
        </member>
        <member name="M:TypeMock.MockManager.Init">
            <overloads>
            <summary>
             Initialize the <c>MockManager</c> 
             This is called automatically
             
             Defaults to collect call information ONLY for mocked classes 
            </summary>
            <seealso cref="P:TypeMock.MockManager.CollectAllCalls"/>
            </overloads>
            <summary>
             Defaults to collect call information ONLY for mocked classes and
             not verbose
            </summary>
        </member>
        <member name="M:TypeMock.MockManager.Init(System.Boolean)">
            <summary>
            Manually set Call Collection and verbose behaviors
            </summary>
            <param name="collectAllCalls">if set, Typemock Isolator collects call information
            for all classes, this can later be verified using <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)"/></param>
        </member>
        <member name="M:TypeMock.MockManager.ClearAll">
            <summary>
            Clears all expectations and mocks  
            </summary>
            <remarks>
            There are times when you want to clear all the expectations of all the mocks.
            For example, if you call <see cref="M:TypeMock.MockManager.Verify"/> in the [TearDown] method, but a
            test failed and you don't want to Verify to cause more test failures.
            
            This is called automatically after <see cref="M:TypeMock.MockManager.Verify"/>.
            (unless <see cref="T:TypeMock.VerifyMode"/> is DontClear
            </remarks>		
        </member>
        <member name="M:TypeMock.MockManager.Mock(System.Type)">
            <overloads>
            <summary>
            Create a new Mock to intercept and mock calls made on the next instance of a type.
            </summary>
            </overloads>
            <param name="type">The Type needed to be mocked</param>
            <returns>New Mock Controller to register expectations</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if an Interface or Abstract Class is
            being Mocked, and if a type is being Mocked twice</exception>
            <summary>
            Automatically mock constructors as well, i.e. constructer code will NOT be called
            </summary>
        </member>
        <member name="M:TypeMock.MockManager.Mock(System.Type,System.Boolean)">
            <summary>
            Create a new Type Mock to intercept and mock calls made on the next instance of a type, 
            with ability to decide if Constructors should be mocked or not (default is to mock constructors)
            </summary>
            <param name="type">The Type needed to be mocked</param>
            <param name="mockConstructors">Should constructors be mocked</param>
            <returns>New Mock Object to control expectations</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if an Interface or Abstract Class is
            being Mocked, if a type is being Mocked twice, or if mocking restricted types (NUnit,TypeMock)</exception>
            <exception cref="T:TypeMock.VerifyException">Will be throw if MockManager is not Initialized <see cref="M:TypeMock.MockManager.Init"/>
            </exception>
        </member>
        <member name="M:TypeMock.MockManager.Mock(System.Type,TypeMock.Constructor)">
            <summary>
            Create a new Type Mock to intercept and mock calls made on the next instance of a type, 
            with ability to define the scope of mocked Constructors (default is to mock all constructors)
            </summary>
            <param name="type">The Type needed to be mocked</param>
            <param name="mockConstructors">Scope of constructors to be mocked</param>
            <returns>New Mock Controller to register expectations</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if an Interface or Abstract Class is
            being Mocked, if a type is being Mocked twice, or if mocking restricted types (NUnit,TypeMock)</exception>
        </member>
        <member name="M:TypeMock.MockManager.MockAll(System.Type)">
            <overloads>
            <summary>
            Create a new Mock to intercept and mock all calls made on all instances of the mocked type.
            </summary>
            <note>
            Each Type can be mocked only once. There is actually no need to mock a type more than once,
            all new objects are mocked as well.
            </note>
            </overloads>
            <param name="type">The Type needed to be mocked</param>
            <returns>New Mock Controller to register expectations</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if an Interface or Abstract Class is
            being Mocked, and if a type is being Mocked twice</exception>
            <summary>
            Automatically mock constructors as well, i.e. constructer code will NOT be called
            </summary>
        </member>
        <member name="M:TypeMock.MockManager.MockAll(System.Type,System.Boolean)">
            <summary>
            Create a new Type Mock for all instances of the type, with ability to decide if Constructors should be mocked or not
            </summary>
            <param name="type">The Type needed to be mocked</param>
            <param name="mockConstructors">Should constructors be mocked</param>
            <returns>New Mock Object</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if an Interface or Abstract Class is
            being Mocked, if a type is being Mocked twice, or if mocking restricted types (NUnit,TypeMock)</exception>
        </member>
        <member name="M:TypeMock.MockManager.MockAll(System.Type,TypeMock.Constructor)">
            <summary>
            Create a new Type Mock for all instances of the type, with ability to to define the scope of mocked Constructors (default is to mock all constructors)
            </summary>
            <param name="type">The Type needed to be mocked</param>
            <param name="mockConstructors">Scope of mocked constructors</param>
            <returns>New Mock Controller to register expectations</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if an Interface or Abstract Class is
            being Mocked, if a type is being Mocked twice, or if mocking restricted types (NUnit,TypeMock)</exception>
        </member>
        <member name="M:TypeMock.MockManager.Mock``1">
            <summary>
            Intercept and mock calls made on the next new instance of TMockedType.
            </summary>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            The Constructor will be mocked!.
            <example>
            <code>
            [Test]
            public void MockTestedClass() 
            {
            	Mock mock = MockManager.Mock&lt;TestedClass&gt;();
            	mock.ExpectCall("SomeMethod");
            
            	TestedClass test = new TestedClass(); // This instance is mocked
            	test.SomeMethod();                    // the method is not called
            
            	MockManager.Verify();                 // Make sure that all expected calls where made
            }
            </code>
            <code lang="VB">
            &lt;Test()&gt; _
            Public Sub MockTestedClass()
            	Dim mock As Mock  = MockManager.Mock(Of TestedClass)()
            	mock.ExpectCall("SomeMethod")
            
            	Dim test As TestedClass = New TestedClass  ' This instance is mocked
            	test.SomeMethod()                          ' the method is not called
            
            	MockManager.Verify()                       ' Make sure that all expected calls where made
            End Sub
            </code>
            </example>
            <seealso cref="M:TypeMock.MockManager.Mock(System.Type)"/><seealso cref="T:TypeMock.Mock"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.Mock``1(TypeMock.Constructor)">
            <summary>
            Intercept and mock calls made on the next new instance of TMockedType, with constructor behavior control
            </summary>
            <param name="mockConstructors">Scope of constructors to be mocked</param>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.Mock``1"/><seealso cref="T:TypeMock.Mock"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.MockAll``1">
            <summary>
            Intercept and mock calls made on the all instance of TMockedType.
            </summary>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            The Constructor will be mocked!
            <example>
            <code>
            [Test]
            public void MockTestedClass() 
            {
            	Mock mock = MockManager.MockAll&lt;TestedClass&gt;();
            	mock.AlwaysExpect("SomeMethod");
            
            	TestedClass test = new TestedClass(); // all instances are mocked
            	test.SomeMethod();                    // the method is not really called
            
            	MockManager.Verify();                 // Make sure that all expected calls where made
            }
            </code>
            <code lang="VB">
            &lt;Test()&gt; _
            Public Sub MockTestedClass()
            	Dim mock As Mock  = MockManager.MockAll(Of TestedClass)()
            	mock.AlwaysExpect("SomeMethod")
            
            	Dim test As TestedClass = New TestedClass  ' all instances are mocked
            	test.SomeMethod()                          ' the method is not really called
            
            	MockManager.Verify()                       ' Make sure that all expected calls where made
            End Sub
            </code>
            </example>
            <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)"/><seealso cref="T:TypeMock.Mock"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.MockAll``1(TypeMock.Constructor)">
            <summary>
            Intercept and mock calls made on the all instance of TMockedType, with constructor behavior control
            </summary>
            <param name="mockConstructors">Scope of constructors to be mocked</param>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.MockAll``1"/><seealso cref="T:TypeMock.Mock"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.IsTypeMocked(System.Type)">
            <summary>
            Check if a type is mocked (with MockAll or instance mocks)
            </summary>
            <param name="type">Type to check</param>
            <returns>true when the type is mocked</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockedTypes"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)">
            <summary>
            Check if a type is mocked for all instances
            </summary>
            <param name="type">Type to check</param>
            <returns>true when the type is mocked for all instances</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockedTypes"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.GetMockAll(System.Type,TypeMock.TypeParams)">
            <summary>
            Returns the mock for all instances of a type, or null if it is not mocked
            </summary>
            <param name="type">Type to return the mock</param>
            <returns>The mock</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockedTypes"/>
            <seealso cref="M:TypeMock.MockManager.GetMocks"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.GetMocks``1">
            <summary>
            Returns all mocks for TMockedType
            </summary>
            <typeparam name="TMockedType">Type being mocked</typeparam>
            <returns>The Mocks</returns>
            <seealso cref="M:TypeMock.MockManager.GetMocks(System.Type)"/>
        </member>
        <member name="M:TypeMock.MockManager.GetMockOf``1(``0)">
             <summary>
             Returns the mock associated with a specific instance
             </summary>
             <typeparam name="T">Type of the instance being mocked</typeparam>
             <param name="instance">The instance to get the mock of</param>
             <returns>If a Mock is associated with the provided instance, returns it. Otherwise, returns null</returns>
             <example>
             Identify a specific mock when using Natural Mocks
             <code>
            [Test]
            public void GetMockOfSpecificInstance()
            {
                 using(RecordExpectations rec = RecorderManager.StartRecording())
                 {
                     TestClass instance1 = new TestClass();
                     TestClass instance2 = new TestClass();
                     TestClass instance3 = new TestClass();
             
                     Mock mock2 = MockManager.GetMockOf(instance2);
                     mock2.ExpectAndReturn("SomeMethod", null);
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:TypeMock.MockManager.GetInstanceMocks``1">
            <summary>
            Returns all instance mocks for TMockedType
            </summary>
            <typeparam name="TMockedType">Type being mocked</typeparam>
            <returns>The Mocks</returns>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
        </member>
        <member name="M:TypeMock.MockManager.GetMockAll``1">
            <summary>
            Returns all instances mock of TMockedType
            </summary>
            <typeparam name="TMockedType">Type being mocked</typeparam>
            <returns>The Mock</returns>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
        </member>
        <member name="M:TypeMock.MockManager.IsTypeMocked``1">
            <summary>
            Check if a type is mocked (with MockAll or instance mocks)
            </summary>
            <typeparam name="TMockedType">Type being mocked</typeparam>
            <returns>true when the type is mocked</returns>
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
        </member>
        <member name="M:TypeMock.MockManager.IsTypeMockedAll``1">
            <summary>
            Check if a type is mocked for all instances
            </summary>
            <typeparam name="TMockedType">Type being mocked</typeparam>
            <returns>true when the type is mocked for all instances</returns>
            <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)"/> 
        </member>
        <member name="M:TypeMock.MockManager.GetMocks(System.Type)">
            <summary>
            Returns all mocks for a type
            </summary>
            <param name="type">Type to return the mock</param>
            <returns>The mock</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockedTypes"/>
            <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.GetMocks">
            <summary>
            Returns all mocks 
            </summary>
            <returns>All the mocks</returns>
            <remarks>
            You can use Mock.<see cref="P:TypeMock.Mock.MockedType"/> to analyse what type is being mocked
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockedTypes"/>
            <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.GetMockedTypes">
            <summary>
            Returns all types that are mocked
            </summary>
            <returns>List of mocked types</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.IsTypeMockedAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetInstanceMocks(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.MockAll(System.Type)"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.GetInstanceMocks(System.Type)">
            <summary>
            Returns a list of instance mocks of a type
            </summary>
            <param name="type">Type to return the instance mocks</param>
            <returns>Array of mocks</returns>
            <remarks>
            <seealso cref="M:TypeMock.MockManager.IsTypeMocked(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMockAll(System.Type)"/>
            <seealso cref="M:TypeMock.MockManager.GetMocks"/>
            <seealso cref="T:TypeMock.Mock"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])">
             <overloads>
             <summary>
             Create a new Dynamic Mock Object and mock all future calls made on the mocked type.
             </summary>
             <note>
             When mocking Interfaces and Abstract classes a new class is created, for concrete classes, a class is instantiated
             </note>
             <note>
             Mocked Objects are Strict by default, unless they are concrete classes
             </note>
             <remarks>
             Example of using Typemock Isolator to create a mock object for IList
             <example>
             <code lang="cs">
             [Test]
            	public void ValidateValidUser()
            		{
            		//Create new Mock Object for IList, all calls to this class, are 
            		//intercepted.
            		MockObject mock = MockManager.MockObject(typeof(IList));
            	
            		// We expect that the Count parameter will be called (once) and we will return 4
            		mock.ExpectGet("Count", 4);
                 // Get our mocked OBJECT
            		IList list = mock.Object as IList;
            
            		// lets just run it, normally the Object will be passes as a parameter to a tested class
            		Assert.AreEqual(4, list.Count);
            	
            		// Verify that all the expected calls have actually been called.
            		MockManager.Verify();
             }
             </code>
             <code lang="vbnet">
             &lt;Test()&gt; _
            	Public Sub ValidateValidUser()
            		' Create new Mock Object for IList, all calls to this class, are 
            		' intercepted.
            		Dim mock As MockObject = MockManager.MockObject(GetType(IList))
            	
            		' We expect that the Count parameter will be called (once) and we will return 4
            		mock.ExpectGet("Count", 4)
                 ' Get our mocked OBJECT
            		Dim list As IList = mock.Object
            
            		' lets just run it, normally the Object will be passes as a parameter to a tested class
            		Assert.AreEqual(4, list.Count)
            	
            		' Verify that all the expected calls have actually been called.
            		MockManager.Verify()
             End Sub
             </code>
             </example>
             </remarks>
             </overloads>
             <param name="type">The Type needed to be mocked</param>
             <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
             <returns>New MockObject Object</returns>
             <summary>
             Automatically mock constructors as well, i.e. constructer code will NOT be called
             </summary>
        </member>
        <member name="M:TypeMock.MockManager.MockObject(System.Type,System.Boolean)">
            <summary>
            Create a new Dynamic Mock Object with ability to decide if Constructors should be mocked or not
            </summary>
            <param name="type">The Type needed to be mocked</param>
            <param name="mockConstructors">Should constructors be mocked</param>
            <returns>New MockObject Object</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a Generic Type Class is
            being Mocked
            </exception>
        </member>
        <member name="M:TypeMock.MockManager.MockObject(System.Type,TypeMock.Constructor,System.Object[])">
            <summary>
            Create a new Dynamic Mock Object with ability to define the scope of mocked Constructors (default is to mock all constructors)
            </summary>
            <param name="type">The Type needed to be mocked</param>
            <param name="mockConstructors">Scope of mocked constructors</param>
            <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
            <returns>New MockObject Object</returns>
            <exception cref="T:TypeMock.TypeMockException">Will be throw if a Generic Type Class is
            being Mocked</exception>
        </member>
        <member name="M:TypeMock.MockManager.MockObject``1">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance.
            </summary>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            The Constructor will be mocked!.
            <para>
            To activate the constructor and send specific arguments use <see cref="M:TypeMock.MockManager.MockObject``1(System.Object[])"/>
            </para>
            <example>
            <code>
            [Test]
            public void MockTestedClass() 
            {
            	MockObject&lt;TestedClass&gt; mockControl = MockManager.MockObject&lt;TestedClass&gt;.Create();
            	mockControl.ExpectCall("SomeMethod");
            
                TestedClass mockedInstance = mockControl.Object; // grab actual instance
            	mockedInstance.SomeMethod();          // the method is not called
            
            	MockManager.Verify();                 // Make sure that all expected calls where made
            }
            </code>
            <code lang="VB">
            &lt;Test()&gt; _
            Public Sub MockTestedClass()
            	Dim mockControl As MockObject(Of TestedClass) = MockManager.MockObject(Of TestedClass)()
            	mockControl.ExpectCall("SomeMethod")
            
            	Dim mockedInstance As TestedClass = mockControl.Object  ' grab actual instance
            	mockedInstance.SomeMethod()                ' the method is not called
            
            	MockManager.Verify()                       ' Make sure that all expected calls where made
            End Sub
            </code>
            </example>
            <seealso cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/><seealso cref="M:TypeMock.MockManager.MockObject``1"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.MockObject``1(TypeMock.Constructor)">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance, while controlling the constructor
            </summary>
            <param name="mockConstructors">Scope of mocked constructors</param>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            For an example see <see cref="M:TypeMock.MockManager.MockObject``1"/>
            <seealso cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/><seealso cref="M:TypeMock.MockManager.MockObject``1"/>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.MockObject``1(System.Object[])">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance, while sending constructor arguments
            </summary>
            <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            For an example see <see cref="M:TypeMock.MockManager.MockObject``1"/>
            <seealso cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/><seealso cref="M:TypeMock.MockManager.MockObject``1"/>
            </remarks>  
        </member>
        <member name="M:TypeMock.MockManager.MockObject``1(TypeMock.Constructor,System.Object[])">
            <summary>
            Create an instance of TMockedType and mock calls made on the instance, while controlling the constructor and sending constructor arguments
            </summary>
            <param name="mockConstructors">Scope of mocked constructors</param>
            <param name="args">Argument for constructor of concrete types, this is ignored for interfaces</param>
            <returns>Mock Controller to define behavior</returns>
            <remarks>
            For an example see <see cref="M:TypeMock.MockManager.MockObject``1"/>
            <seealso cref="M:TypeMock.MockManager.MockObject(System.Type,System.Object[])"/><seealso cref="M:TypeMock.MockManager.MockObject``1"/>
            </remarks>  
        </member>
        <member name="M:TypeMock.MockManager.MockReturnObject(System.Type,TypeMock.Constructor,System.Object[])">
            <summary>
            Same as MockObject but doesn't check for mocked while locked
            </summary>
            <param name="type"></param>
            <param name="mockConstructors"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:TypeMock.MockManager.MockGlobalFunctions">
            <summary>
            Use this type when mocking global functions
            </summary>
            <remarks>
            This is an example of how to mock global functions in C++
            <example>
            <code>
            // Managed C++
            namespace TestWithCpp
            {
            	int globalFunction(int a) {return a;}
            }
            </code>
            And the test
            <code>
            // Managed C++
            [Test]
            void Global() {
            	Mock* mock = MockManager::MockGlobalFunctions();
            	// Notice the '.' and NOT '::' !!!
            	mock->ExpectAndReturn("TestWithCpp<b>.</b>globalFunction",__box(5));
            	Assert::AreEqual(__box(5), __box(globalFunction(4)));
            }	
            </code>
            </example>
            </remarks>
            <returns>New Mock Object</returns>
        </member>
        <member name="M:TypeMock.MockManager.Verify">
            <summary>
            Verify all mocked types 
            </summary>
            <remarks>
            Part of Test Driven Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. This should always be the final part of the test
            If some methods that we expected to be called where not called this will fail the test.
            <note>
            Using <see cref="P:TypeMock.Mock.Strict"/> we can also define, that calls to methods that where
            not expected, will fail the test too.
            </note>
            <note>
            Mocked static members are verified only when the last instance of a type is Verified.
            </note>
            </remarks>
        </member>
        <member name="M:TypeMock.MockManager.VerifyWithTimeout">
            <summary>
            Wait with timeout (5 seconds) for all expected methods to be called
            </summary>
            <remarks>
            VerifyWithTimeout will wait for all expectations to be called. If the Timeout is triggered
            the test will fail. 
            Part of Test Driver Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. There are cases when mocks are called in a-synchronic
            code or are encapsulated in a try catch block and errors are not thrown to testing method.
            In these cases using VerifyWithTimeout will enable us to validate our code and return as soon as
            the expected methods are called without needing to add Pause statements
            
            <example>
            <code lang="cs">
            [Test]
            public void TestCallsInOtherThread ()
            {
            	// Let mock the product -  it will not mock constructors;
            	Mock productMock = MockManager.Mock(typeof(Product),Constructor.NotMocked);
            	// CalculatePrice will return 10 - expect 10 as argument
            	productMock.ExpectAndReturn("CalculatePrice",10F).Args(10);
            	// our method will be called in a new thread
            	Thread theThread = new Thread(new ThreadStart(RunWithWait));
            	theThread.Start();
            	// If we use Verify we dont know when the thread will actually be called
            	// Here we WAIT for the mocked methods to be called, or the timeout.
            	// Default timeout is 5000 milliseconds
            	MockManager.VerifyWithTimeout();		
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestCallsInOtherThread()
               ' Let mock the product - this will mock the next invocation of Product,
               ' it will mock constructors too so our price will be 0
               Dim productMock As Mock = MockManager.Mock(GetType(Product), Constructor.NotMocked)
               ' CalculatePrice will return 10 - expect 10 as argument
               productMock.ExpectAndReturn("CalculatePrice", 10.0F).Args(10)
               ' our method will be called in a new thread
               Dim theThread As Thread = New Thread(AddressOf RunWithWait)
               theThread.Start()
               ' If we use Verify we dont know when the thread will actually be called
               ' Here we WAIT for the mocked methods to be called, or the timeout.
               ' Default timeout is 5000 milliseconds
               MockManager.VerifyWithTimeout()
            End Sub
            </code>
            </example>
            </remarks>		
        </member>
        <member name="M:TypeMock.MockManager.VerifyWithTimeout(System.Int32)">
            <summary>
            Wait with timeout (im milliseconds) for all expected methods to be called
            </summary>
            <remarks>
            VerifyWithTimeout will wait for all expectations to be called. If the Timeout is triggered
            the test will fail. 
            Part of Test Driver Development and Mock Methodology is being sure that ALL our
            expected calls where actually called. There are cases when mocks are called in a-synchronic
            code or are encapsulated in a try catch block and errors are not thrown to testing method.
            In these cases using VerifyWithTimeout will enable us to validate our code and return as soon as
            the expected methods are called without needing to add Pause statements
            
            <example>
            <code lang="cs">
            [Test]
            public void TestCallsInOtherThread ()
            {
            	// Let mock the product -  it will not mock constructors;
            	Mock productMock = MockManager.Mock(typeof(Product),Constructor.NotMocked);
            	// CalculatePrice will return 10 - expect 10 as argument
            	productMock.ExpectAndReturn("CalculatePrice",10F).Args(10);
            	// our method will be called in a new thread
            	Thread theThread = new Thread(new ThreadStart(RunWithWait));
            	theThread.Start();
            	// If we use Verify we dont know when the thread will actually be called
            	// Here we WAIT 1000 milliseconds for the mocked methods to be called, or the timeout.
            	MockManager.VerifyWithTimeout(1000);		
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub TestCallsInOtherThread()
               ' Let mock the product - this will mock the next invocation of Product,
               ' it will mock constructors too so our price will be 0
               Dim productMock As Mock = MockManager.Mock(GetType(Product), Constructor.NotMocked)
               ' CalculatePrice will return 10 - expect 10 as argument
               productMock.ExpectAndReturn("CalculatePrice", 10.0F).Args(10)
               ' our method will be called in a new thread
               Dim theThread As Thread = New Thread(AddressOf RunWithWait)
               theThread.Start()
               ' If we use Verify we dont know when the thread will actually be called
               ' Here we WAIT 1000 milliseconds for the mocked methods to be called, or the timeout.
               MockManager.VerifyWithTimeout(1000)
            End Sub
            </code>
            </example>
            </remarks>			
            <param name="millisecondsTimeout">Time to wait for all expected methods to be called</param>
        </member>
        <member name="M:TypeMock.MockManager.CalledCounter(System.String,System.String)">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <remarks>
            Can be used as part of a validation. 
            <example>
            In the following example we validate that the doSomething() Method has been called 3 times, 
            while keeping the original functionality (not mocked)
            </example>
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// init collecting on
            	MockManager.Init(true);
            	TestedClass t = new TestedClass();
            	t.doSomething();
            	t.doSomething();
            	t.doSomething();
            	Assert.AreEqual(3,MockManager.CalledCounter("TestClassLibrary.TestedClass","doSomething"));
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	' init collecting on
            	MockManager.Init(true)
            	Dim t As TestedClass = New TestedClass
            	t.doSomething()
            	t.doSomething()
            	t.doSomething()
            	Assert.AreEqual(3,MockManager.CalledCounter("TestClassLibrary.TestedClass","doSomething"))
            End Sub
            </code>
            For Properties and Indexers see <see cref="M:TypeMock.MockManager.CalledPropertyGetCounter(System.String,System.String)"/> ,
            <see cref="M:TypeMock.MockManager.CalledPropertySetCounter(System.String,System.String)"/> and <see cref="M:TypeMock.MockManager.CalledIndexerCounter(System.String)"/>
            <note>
            Calls from Types of the System.* namespace will not be collected until the type is mocked
            </note>
            </remarks>
            <param name="type">String representation of Type</param>
            <param name="methodName">String representation of Method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledCounter(System.Type,System.String)">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <param name="type">The type we want count one of its methods</param>
            <param name="methodName">String representation of Method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledCounter(System.Type,System.String,System.Type[])">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <param name="type">The type we want count one of its methods</param>
            <param name="methodName">String representation of Method</param>
            <param name="genericMethodTypes">Generic parameters list of the method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledCounter``1(System.String)">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <typeparam name="TMockType"></typeparam>
            <param name="method">String representation of Method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledCounter``1(System.String,System.Type[])">
            <summary>
            Return the amount of times a method has been called
            </summary>
            <typeparam name="TMockType"></typeparam>
            <param name="method">String representation of Method</param>
            <param name="genericMethodParams">Generic parameters list of the method</param>
            <returns>Number of times the method has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledPropertyGetCounter(System.String,System.String)">
            <summary>
            Return the amount of times a property has been called
            </summary>
            <remarks>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)"/>
            </remarks>
            <param name="type">String representation of Type</param>
            <param name="propertyName">String representation of the Property</param>
            <returns>Number of times the property has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledPropertySetCounter(System.String,System.String)">
            <summary>
            Return the amount of times a property has been set
            </summary>
            <remarks>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)"/>
            </remarks>
            <param name="type">String representation of Type</param>
            <param name="propertyName">String representation of the Property</param>
            <returns>Number of times the property has been set</returns>
        </member>
        <member name="M:TypeMock.MockManager.CalledIndexerCounter(System.String)">
            <summary>
            Return the amount of times an indexer has been called
            </summary>
            <remarks>
            See <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)"/>
            </remarks>
            <param name="type">String representation of Type</param>
            <returns>Number of times the indexer has been called</returns>
        </member>
        <member name="M:TypeMock.MockManager.ShowEnterprise(System.String,TypeMock.AboutMessage)">
            <summary>
            Part of Message and message will concatenated in "About" in order
            to show user exact message
            </summary>
            <param name="partOfMessage"></param>
            <param name="msg"></param>
        </member>
        <member name="M:TypeMock.MockManager.ShowEnterprise(System.String,TypeMock.AboutMessage,System.Int32)">
            <summary>
            Part of Message and message will concatenated in "About" in order
            to show user exact message
            </summary>
            <param name="partOfMessage"></param>
            <param name="msg"></param>
            <param name="days"></param>
        </member>
        <member name="M:TypeMock.MockManager.ShowEnterprise(System.String,TypeMock.CoreEnum)">
            <summary>
            Part of Message and message will concatenated in "About" in order
            to show user exact message
            </summary>
            <param name="PartOfMessage"></param>
            <param name="result"></param>
        </member>
        <member name="P:TypeMock.MockManager.Version">
            <summary>
            Return Typemock Isolator version
            </summary>
        </member>
        <member name="P:TypeMock.MockManager.LogFile">
            <summary>
            Obsolete, use running options instead,
            When set Typemock Isolator creates a log-file 
            </summary>
            <remarks>
            Creates a log-file called TypeMock.out in the application directory
            This is mainly for debugging Typemock Isolator itself, it is also possible to set the TMOCK_VERIFY environment
            variable to 1, before running the executable
            The log-file logs the code weaving process
            </remarks>
        </member>
        <member name="P:TypeMock.MockManager.CollectAllCalls">
            <summary>
            When set Typemock Isolator collects data on ALL method entries, this can then be verified 
            using <see cref="M:TypeMock.MockManager.CalledCounter(System.String,System.String)"/>
            </summary>
        </member>
        <member name="P:TypeMock.MockManager.IsInitialized">
            <summary>
            Check if Typemock Isolator is initialized <see cref="M:TypeMock.MockManager.Init"/>
            </summary>
        </member>
        <member name="P:TypeMock.MockManager.ValidateArgsOnVerify">
            <summary>
            Obsolete. Argument validation is now done both on calling the method and during Verify automatically.
            Postpone throwing validation errors till <see cref="M:TypeMock.MockManager.Verify"/> is called
            </summary>
            <remarks>
            Using ValidateArgsOnVerify, validation errors are thrown after Verify is called.
            This is useful if the validation is done in another thread and you want the thread to continue.
            When Verify is called all argument validations are shown too.
            </remarks>
            The flag will be deleted in future
        </member>
        <member name="P:TypeMock.MockManager.Any">
            <summary>
            Obsolete, use Check.<see cref="M:TypeMock.Check.IsAny"/> instead,
            Provided for backward compatibility
            <seealso cref="M:TypeMock.Check.IsAny"/>
            </summary>
        </member>
        <member name="P:TypeMock.MockManager.CONTINUE_WITH_METHOD">
            <summary>
            If CONTINUE_WITH_METHOD is returned the mocked method will continue with
            normal execution. This is an un-mocked expectation that will verify that a method is called only
            without mocking the method. 
            </summary>
            <remarks><note>Using handling ref and out parameters in un-mocked mode is tricky as the method is run as normal. See <see cref="T:TypeMock.Assign"/><seealso cref="T:TypeMock.Assign"/> </note></remarks>
        </member>
        <member name="T:TypeMock.ClearMocksAttribute">
            <summary> Used to clean up the defined expectations on MockManager at the end of
            each test. This class cant be inherited.</summary>
            <remarks>Any method marks with this attribute will clean all set expectation
            after the test is done. A marked class will do this for any test defined in
            it.</remarks>
            <example>
            <code lang="cs">
            [TestFixture]
            [ClearMocks]  // clear all mocks between tests
            public TestClass
            {
                [Test]
                public void MyTest1()
                {
                    // the test code
                }
            }</code>
            
            <code lang="vbnet">
            &lt; TestFixture &gt;_
            &lt; ClearMocks &gt;_ ' clear all mocks between tests
            Public class TestClass
                &lt; Test &gt;_
                Public Sub MyTest1()
                   ' the test code
                End Sub
            End Class
            </code>
            </example>
            <seealso cref="T:TypeMock.VerifyMocksAttribute">VerifyMocksAttribute</seealso>
        </member>
        <member name="M:TypeMock.ClearMocksAttribute.Execute">
            <summary>
            Called by the framework instead of the original method. This will run the original method and 
            afterwards clear the Mock Manager.
            </summary>
            <returns> the result of the original method</returns>
        </member>
        <member name="T:TypeMock.ParameterCheckerEventArgs">
            <summary>
            Arguments received in custom parameter checker see (<see cref="T:TypeMock.ParameterChecker"/>
            </summary>
            <remarks><seealso cref="T:TypeMock.ParameterChecker"/></remarks>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.ArgumentValue">
            <summary>
            Value of the argument passed to method
            </summary>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.ArgumentPosition">
            <summary>
            Position of the argument in the called method
            </summary>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.FailureMessage">
            <summary>
            The Message to display if check fails
            </summary>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.CallingType">
            <summary>
            Type in which the method was called from
            </summary>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.CallingMethodName">
            <summary>
            Name of method that was called
            </summary>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.ExpectedValue">
            <summary>
            Expected value - set only when <see cref="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)"/> is used
            </summary>
            <remarks>
            This property is set when <see cref="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)"/> is used.
            <seealso cref="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)"/>
            </remarks>
        </member>
        <member name="P:TypeMock.ParameterCheckerEventArgs.MessagePrefix">
            <summary>
            Default message prefix that can be added to the <see cref="P:TypeMock.ParameterCheckerEventArgs.FailureMessage"/>
            </summary>
            <remarks>
            The message is: Call to [namespace.method] Parameter: [number] 
            </remarks>
        </member>
        <member name="T:TypeMock.ParameterCheckerEx">
            <summary>
            Delegate to implement a custom parameter checker 
            </summary>
            <remarks>
            Typemock Isolator validates parameter values, collections and arrays automatically
            there are some cases where this is not enough and a custom checker is needed,
            to do so create a check delegation and pass it as a parameter 
            to <c>Args</c> see <see cref="T:TypeMock.IParameters"/> and <see cref="T:TypeMock.Mock"/>
            <para>
            <example>
            For example, if we need to check that an <c>int</c> parameter is larger then 10
            we can write the following code 
            <code lang="cs">
            public static bool CheckRange(ParameterCheckerEventArgs data)
            {
            	return (int)data.ArgumentValue &gt; 10;
            }
            </code>
            <code lang="vbnet">
            Public Shared Function CheckRange(ByVal data As ParameterCheckerEventArgs) As Boolean
            	CheckRange = data.ArgumentValue &gt; 10;
            End Function
            </code>
            We can then use it in out test
            <code lang="cs">
            [Test]
            public void Test()
            {
            	TestedClass t = new TestedClass();
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	// passInt will be called, arguments must agree with MyChecker
            	mock.ExpectAlways("passInt").Args(new ParameterCheckerEx(CheckRange));
            	// This will pass 
            	t.passInt(16);
            	// This will fail 
            	t.passInt(3);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	Dim t As TestedClass = new TestedClass
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	' passInt will be called, arguments must agree with MyChecker
            	mock.ExpectAlways("passInt").Args(New ParameterCheckerEx(AddressOf CheckRange))
            	// This will pass 
            	t.passInt(16)
            	// This will fail 
            	t.passInt(3)
            	MockManager.Verify()
            }
            </code>
            </example>
            </para>
            See <see cref="T:TypeMock.Check"/> for built in ParameterCheckers 
            See Check.<see cref="M:TypeMock.Check.CustomChecker(TypeMock.ParameterCheckerEx,System.Object)"/> to pass an object to the delegate
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            </remarks>
            <param name="data">Data of real parameter value that was passed to the mocked method</param>
            <returns>True for parameter values that are expected </returns>
        </member>
        <member name="T:TypeMock.ParameterChecker">
            <summary>
            This might become Obsolete, please use ParameterCheckerEx. Delegate to implement a custom parameter checker 
            </summary>
            <remarks>
            Typemock Isolator validates parameter values, collections and arrays automatically
            there are some cases where this is not enough and a custom checker is needed,
            to do so create a check delegation and pass it as a parameter 
            to <c>Args</c> see <see cref="T:TypeMock.IParameters"/> and <see cref="T:TypeMock.Mock"/>
            <para>
            <example>
            For example, if we need to check that an <c>int</c> parameter is larger then 10
            we can write the following code 
            <code lang="cs">
            public static bool CheckRange(object parameter)
            {
            	return (int)parameter &gt; 10;
            }
            </code>
            <code lang="vbnet">
            Public Shared Function CheckRange(ByVal parameter As Object) As Boolean
            	CheckRange = parameter &gt; 10;
            End Function
            </code>
            We can then use it in out test
            <code lang="cs">
            [Test]
            public void Test()
            {
            	TestedClass t = new TestedClass();
            	// Start mocking TestedClass
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	// passInt will be called, arguments must agree with MyChecker
            	mock.ExpectAlways("passInt").Args(new ParameterChecker(CheckRange));
            	// This will pass 
            	t.passInt(16);
            	// This will fail 
            	t.passInt(3);
            	MockManager.Verify();
            }
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub Test()
            	Dim t As TestedClass = new TestedClass
            	' Start mocking TestedClass
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	' passInt will be called, arguments must agree with MyChecker
            	mock.ExpectAlways("passInt").Args(New ParameterChecker(AddressOf CheckRange))
            	// This will pass 
            	t.passInt(16)
            	// This will fail 
            	t.passInt(3)
            	MockManager.Verify()
            End Sub
            </code>
            </example>
            </para>
            See <see cref="T:TypeMock.Check"/> for built in ParameterCheckers 
            <seealso cref="T:TypeMock.Check"/>
            <seealso cref="T:TypeMock.IParameters"/>
            </remarks>
            <param name="parameter">The real parameter value that was passed to the mocked method</param>
            <returns>True for parameter values that are expected </returns>
        </member>
        <member name="T:TypeMock.IsCloseCheck">
            <summary>
            Summary description for IsCloseCheck.
            </summary>
        </member>
        <member name="T:TypeMock.Assign">
            <summary>
            Passing this class as to Args as a Parameter Checker to mock ref and out parameters. Enterprise
            Edition users can swap normal argument too.
            See <see cref="T:TypeMock.IParameters"/>
            </summary>
            <remarks>
            Use this class to mock ref and out parameters. Enterprise Edition Users can use the Assign 
            class to replace arguments of a method at run time. This is useful in conjunction with 
            Mock.<see cref="M:TypeMock.Mock.ExpectUnmockedCall(System.String,System.Type[])"/> and complex types, where it is easier to change 
            an argument then to mock all the methods.
            <exmaple>
            Here is an example of using Assign
            <code lang="cs">
            [Test]
            public void CheckRefAndOut() 
            {
            	Mock mock = MockManager.Mock(typeof(TestedClass));
            	TestedClass t = new TestedClass();
            	// Check that first arg is "rr" and assign it with "changed"
            	// Assign the second arg with 3, don't check (same as Check.IsAny())
            	mock.ExpectCall("SomeMethod").Args(new Assign("changed").AndCheck("rr"), new Assign(3));
            	int a ;
            	string s = "rr";
            	t.SomeMethod(ref s,out a);
            	Assert.AreEqual(3,a);
            	Assert.AreEqual("changed",s);
            	MockManager.Verify();
            }
            
            </code>
            <code lang="vbnet">
            &lt;Test()&gt; _
            Public Sub CheckRefAndOut()
            	Dim mock As Mock = MockManager.Mock(GetType(TestedClass))
            	Dim t As TestedClass = New TestedClass
            	' Check that first arg is "rr" and assign it with "changed"
            	' Assign the second arg with 3, don't check (same as Check.IsAny())
            	mock.ExpectCall("SomeMethod").Args(New Assign("changed").AndCheck("rr"), New Assign(3))
            	Dim a As Integer
            	Dim s As String = "rr"
            	t.SomeMethod(s,a)
            	Assert.AreEqual(3,a)
            	Assert.AreEqual("changed",s)
            	MockManager.Verify()
            End Sub
            
            </code>
            </exmaple>
            Another way to assign ref and out parameter is by using the <see cref="T:TypeMock.DynamicReturnValue"/>
            <note>Typemock Isolator doesn't check that the parameter is actually passed by ref</note>
            <note>Assign will might work correctly for un-mocked expectations. See <see cref="P:TypeMock.MockManager.CONTINUE_WITH_METHOD"/></note>
            <note>Assigning arrays is currently not supported</note>
            </remarks>
        </member>
        <member name="M:TypeMock.Assign.#ctor(System.Object)">
            <summary>
            Create a new Assign object that will mock ref and out arguments
            </summary>
            <remarks>
            Use in conjunction with <see cref="T:TypeMock.IParameters"/>
            </remarks>
            <param name="value">The value to assign the parameter</param>
        </member>
        <member name="M:TypeMock.Assign.AndCheck(System.Object)">
            <summary>
            Validate the parameter before assigning it a value.
            </summary>
            <param name="expectation">Expected value or parameter checker</param>
            <returns>The parameter assigner</returns>
        </member>
        <member name="T:ThreadMessaging.DumpContainer">
            <exclude/>
        </member>
        <member name="M:ThreadMessaging.DumpContainer.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ThreadMessaging.DumpContainer.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:ThreadMessaging.DumpContainer.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:TypeMock.MockedEventsList">
            <summary>
            List of mocked events.
            <para>
            When more than one instance of the event published is mocked, use the MockedEvent.<see cref="P:TypeMock.MockedEvent.Instance"/>[index] property.
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.
            </para>
            <see cref="T:TypeMock.IMockedEvent"/>
            </summary>
            <remarks>
            Since Version 3.7
            </remarks>
        </member>
        <member name="P:TypeMock.MockedEventsList.Count">
            <summary>
            Return the number of mocked events in the list
            </summary>
        </member>
        <member name="P:TypeMock.MockedEventsList.Item(System.Int32)">
            <summary>
            Get an <see cref="T:TypeMock.IMockedEvent"/> that was previously registers. 
            <para>
            The first instance to register to the event will be in index 0, the next instance in 1 and so on.</para> 
            </summary>
            <param name="index">The index of the <see cref="T:TypeMock.IMockedEvent"/> to retrieve</param>
            <returns>The <see cref="T:TypeMock.IMockedEvent"/></returns>
        </member>
        <member name="F:TypeMock.Internal.StaticConstructorsHandler.recordedType">
            <summary>
            contain the list of all types that their cctor was encountered during
            the recording phase and therefore was not activated.
            </summary>
        </member>
        <member name="T:TypeMock.DefaultRecordBehavior">
            <summary>
            Change the default Behavior of Natural Mocks™
            </summary>
            <remarks>
            The default Behavior of Natural Mocks is
            <list type="bullet">
            <item>Repeat once (See <see cref="M:TypeMock.IMockBehavior.Repeat(System.Int32)"/>)</item> 
            <item>Ignore Arguments (See <see cref="M:TypeMock.IMockBehavior.IgnoreArguments"/>)</item>
            </list>
            To change this use DefaultBehavior.
            This is useful for chained natural mocks where we require the whole chain to be checked.
            <para>
            <example>
            Example of using Natural Mocks™ repeat always, 
            we will always return 10 when GetSomething().DoSomething() is called from any TestedClass instance
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   // make all future instances mocked and all statements repeat
                   recorder.DefaultBehavior.RepeatAlways();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething().DoSomething();
                   // always return 10
                   recorder.Return(10);
                }
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   ' make all future instances mocked and all statements repeat
                   recorder.DefaultBehavior.RepeatAlways()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething().DoSomething()
                   ' always return 10
                   recorder.Return(10)
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            <seealso cref="P:TypeMock.RecordExpectations.DefaultBehavior"/>
            </remarks>     
        </member>
        <member name="M:TypeMock.DefaultRecordBehavior.CheckArguments">
            <summary>
            Check All Arguments of statements
            </summary>
            <remarks>
            Using CheckArguments will fail tests if the arguments actually passed are not those that where expected.
            Special care must be taken when changing the default expectation, as the statement CheckArguments now
            must include an item for all arguments passed.
            <para>
            <example>
            Example of using Natural Mocks™ CheckArguments with multiple statements, 
            we will validate that GetSomething("TypeMock").DoSomething("magic") is called with "TypeMock" and "magic"
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething("TypeMock").DoSomething("magic");
                }
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething("TypeMock").DoSomething("magic")
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            <example>
            Example of using Natural Mocks™ CheckArguments with multiple statements, 
            we will validate the arguments with built-in checks
            <code lang="cs">
            [Test]
            public void Test()
            {
            	// Start mocking 
                using (RecordExpectations recorder = RecorderManager.StartRecording())
                {
                   // CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments();
                   // Mock (all) new instance of TestedClass
                   TestedClass mockedTestedClass = new TestedClass();
                   // DoSomething to be mocked.
                   mockedTestedClass.GetSomething(null).DoSomething(null);
                   recorder.CheckArguments(Check.IsIn("TypeMock", "NaturalMock"),Check.StartsWith("s"));
                }
            }
            </code>
            <code lang="vbnet">
            ' Visual Basic .NET 2.0
            &lt;Test()&gt; _
            Public Sub Test()
            	' Start mocking 
                Using recorder As New RecordExpectations
                   ' CAUTION: ALL calls here are mocked!!!
                   recorder.DefaultBehavior.CheckArguments()
                   ' Mock (all) new instance of TestedClass
                   Dim mockedTestedClass As TestedClass = New TestedClass
                   ' DoSomething to be mocked.
                   mockedTestedClass.GetSomething(null).DoSomething(null);
                   recorder.CheckArguments(Check.IsIn("TypeMock","NaturalMock"),Check.StartsWith("s"))
                End Using
            End Sub
            </code>
            For VB .NET 1.1 see <see cref="T:TypeMock.RecordExpectations"/>
            </example>
            </para>
            <seealso cref="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])"/>
            </remarks>
        </member>
        <member name="M:TypeMock.DefaultRecordBehavior.WhenArgumentsMatch">
            <summary>
            Mock method only when arguments passed are as expected
            </summary>
            <remarks>
            See <see cref="M:TypeMock.IMockBehavior.WhenArgumentsMatch(System.Object[])"/>
            <note>Care should be taken when using this in a chained statement.
            There is no backtracking and after one method is mocked a mock is returned even if the next statement
            is not mocked.
            </note>
            <seealso cref="M:TypeMock.IMockBehavior.WhenArgumentsMatch(System.Object[])"/>
            </remarks>
        </member>
        <member name="M:TypeMock.DefaultRecordBehavior.IgnoreArguments">
            <summary>
            Don't verify arguments, this is the default.
            </summary>
            <remarks>
            <seealso cref="M:TypeMock.IMockBehavior.CheckArguments(System.Object[])"/>
            </remarks>
        </member>
        <member name="M:TypeMock.DefaultRecordBehavior.Repeat(System.Int32)">
            <summary>
            Repeat each statement. 
            </summary>
            <remarks>See <seealso cref="M:TypeMock.IMockBehavior.Repeat(System.Int32)"/>
            </remarks>
            <param name="timesToRun">Amount of times to repeat the expectation</param>
            <returns>Use to change more Behavior</returns>
        </member>
        <member name="M:TypeMock.DefaultRecordBehavior.RepeatAlways">
            <summary>
            Repeat each statement for every call. 
            </summary>
            <remarks>See <seealso cref="M:TypeMock.IMockBehavior.RepeatAlways"/>
            </remarks>
            <returns>Use to change more Behavior</returns>
        </member>
        <member name="P:TypeMock.DefaultRecordBehavior.Strict">
            <summary>
            Flags that define the behavior of Arbitrary (not expected) calls.
            The default is the Methods of Abstract and Interfaces are Strict and Arbitrary calls fail
            while Arbitrary Methods of concrete classes are allowed.
            </summary>
            <remarks>
            When testing for mock interactions there are times when the default behavior needs to be changed, 
            the StrictFlags define which arbitrary methods we allow.
            <note>
            When allowing arbitrary abstract methods (methods created dynamically by Typemock Isolator using <see cref="M:TypeMock.MockManager.MockObject(System.Type,TypeMock.Constructor,System.Object[])"/> or <see cref="M:TypeMock.RecorderManager.CreateMockedObject(System.Type,TypeMock.StrictFlags,System.Object[])"/>), 
            Typemock Isolator create the following default behavior:
            1. All void calls just return
            2. Other Methods will return 0 or null depending on the return type
            3. Properties will behave like normal properties
            </note>
            <note> To set only one method to strict use: <see cref="M:TypeMock.Mock.MethodSettings(System.String)"/> or <see cref="M:TypeMock.RecordExpectations.FailWhenCalled(System.Object)"/>
            </note>
            </remarks>
        </member>
        <member name="P:TypeMock.DefaultRecordBehavior.AutomaticFieldMocking">
            <summary>
            Flags that define the behavior of Field handling calls.
            By default internal fields are mocked according to the state of the appropriate 
            constructor(i.e. if the constructor is mocked then the field will be mocked as well),
            which means that any uninitialized field (its value is null) will be replaced with a mocked 
            object during the recording phase.
            values of static fields will be reverted back at the end of the test before any calls to 
            a method on the class. 
            </summary>
            <remarks>
            only the immediate level of fields is automatically mocked. i.e. fields of fields are not mocked.
            </remarks>
        </member>
        <member name="P:TypeMock.DefaultRecordBehavior.MockStaticConstructors">
            <summary>
            Flags that define the default behavior of static constructors mocking.
            By default all static constructors of objects created inside a recording block will 
            not be mocked. 
            Setting this flag to true will cause static constructors of newly created object to be mocked.
            (the real static constructor will be executed when needed after the test ends.)
            </summary>
        </member>
        <member name="T:TypeMock.InternalCheck">
            <summary>
            Summary description for InternalCheck.
            </summary>
        </member>
    </members>
</doc>
